/*  ========== solve.cpp =========    Contem funcoes para resolver as equacoes    de Navier-Stokes*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <math.h>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                              solveSuperSonicSIMPLEC()           Resolver por SIMPLEC (acoplamento pressao-velocidade/densidade)    o escoamento supersonico.Criado por Andre STALTZ dia 31/03/07______________________________________________________________________________*/void solveSuperSonicSIMPLEC( Grid *malha ){    bool convergiu = false;    int  iteracoesC = 0,         iteracoesB = 0,         iteracoesA = 0;    do // Ciclo A -------------------------------------------------------------    {        atualizaParametrosDaIteracaoAnterior( malha, 'A' );        interpolaTodasInterfaces( malha, 'A', false );        iteracoesB = 0;        do // Ciclo B -------------------------------------------------------------        {            atualizaParametrosDaIteracaoAnterior( malha, 'B' );            interpolaTodasInterfaces( malha, 'B', false );            atualiza_Gamma( malha );            atualiza_Beta( malha );            // Calcula entrada e saida de massa para satisfazer conservacao            //calculaFluxosMassa( malha );            // Item 2. (calcular os coeficientes do momentum de u* e v*)            calculaCoeficientesMomento( malha );            iteracoesC = 0;            do // Ciclo C ---------------------------------------------------------            {                atualizaParametrosDaIteracaoAnterior( malha, 'C' );                calculaTermoFonteMomento( malha );                // Item 3.                calculaCoeficientesCorrecaoPressao( malha );                // Item 4. (campo de velocidades u* e v* e' determinado)                cout << "Resolvendo matriz do momento-x...\t";                gradienteBiconjugadoEstabilizado( malha, ID_VAR_U );                cout << "Resolvendo matriz do momento-y...\t";                gradienteBiconjugadoEstabilizado( malha, ID_VAR_V );                calculaVelocidadesNasFaces( malha );                // Item 5. Termo fonte (b^P')                calculaTermoFonteCorrecaoPressao( malha );                // Item 6a. Resolver a equacao para P'                cout << "Resolvendo matriz de pressao'...\t";                gradienteBiconjugadoEstabilizado( malha, ID_VAR_PLINHA );                // Item 6b e 6c. Corrigir u*, v*, rho* e P*                      corrige_Velocidades_Densidades_Pressoes( malha, RELAXAMENTO_P,                                                         RELAXAMENTO_U, RELAXAMENTO_V );                // Verifica convergencia                if( convergenciaPressao( malha ) == SUCESSO )                    convergiu = true;                else                    convergiu = false;                iteracoesC++;                cout << endl;            // Item 7. Retorna ao item 3 ate' convergir ---------------------------            } while( !convergiu && iteracoesC < MAXITER_C ); // Ciclo C            cout << "\nIteracoes do ciclo C (Cor. Pressao): " << iteracoesC << endl;            // Verifica convergencia            if( convergenciaVelocidades( malha ) == SUCESSO )                convergiu = true;            else                convergiu = false;            iteracoesB++;        // Item 8. Retorna ao item 2 ate' convergir -------------------------------        } while( !convergiu && iteracoesB < MAXITER_B ); // Ciclo B        cout << "\nIteracoes do ciclo B (Velocidades): " << iteracoesB << endl;        // Item 9.        // Calcular os coeficientes da equacao de energia        calculaCoeficientesEnergia( malha );        // Resolve a equacao de energia total        cout << "Resolvendo matriz da energia total...\t";        gradienteBiconjugadoEstabilizado( malha, ID_VAR_T );        //imprimeMatriz( malha, ID_VAR_T );        // Campos de T, rho, mi, k sao determinados        atualizaOutrosEscalares( malha, RELAXAMENTO_T );        // Verifica convergencia da temperatura        if( convergenciaTemperatura( malha ) == SUCESSO )            convergiu = true;        else            convergiu = false;        iteracoesA++;    // Item 11. Retorna ao item 2 ate' convergir    } while( !convergiu && iteracoesA < MAXITER_A ); // Ciclo A    cout << "\nIteracoes do ciclo A (Temperatura): " << iteracoesA << endl;    // A solucao do problema em t + deltaT foi obtida!    cout << " Tempo atual: " << malha->tempoAtual << " s ################################" << endl;}/*______________________________________________________________________________                              condicaoInicial()           Configura as variaveis na condicao inicial, ou seja, em t = 0.______________________________________________________________________________*/int condicaoInicial( Grid *malha ){    Cell *celula;    // Ajusta tempo para zero    malha->tempoAtual = 0.0;    //malha->cortarMalha(0.5);    definirCelulasFronteira( malha );    if(malha->firstGridCell != NULL)    {        // Ajustar todas as celulas com a configuracao inicial        for(celula = malha->firstGridCell;            celula != 0;             celula = celula->next)        {            if( celula->active )            {                // Variaveis de fluido                celula->pAtual = PRESSAO_LIVRE;                celula->pAnterior = celula->pAtual;                if(celula->volumeFicticio && celula->direcaoFronteira == FRONTEIRA_SUL)                {                    celula->uAtual = -VEL_LIVRE;                    celula->uAnterior = -VEL_LIVRE;                }                else                {                    celula->uAtual = VEL_LIVRE;                     celula->uAnterior = VEL_LIVRE;                }                celula->vAtual = 0.0;                 celula->vAnterior = celula->vAtual;                celula->TAtual = TEMPERATURA_LIVRE;                celula->TAnterior = TEMPERATURA_LIVRE;                celula->rhoAtual = PRESSAO_LIVRE / (R*celula->TAtual);                celula->rhoAnterior = PRESSAO_LIVRE / (R*celula->TAtual);                celula->miAtual = MI_ZERO;                celula->miAnterior = celula->miAtual;                celula->kAtual = (MI_ZERO * GAMMA * R) / ((GAMMA - 1.0) * PRANDTL);                celula->kAnterior = celula->kAtual;            }        }        interpolaTodasInterfaces( malha, 'A', true );        return SUCESSO;    }    else    {        cout << "Na funcao condicaoInicial():\n";        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao condicaoInicial():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*____________________________________________________________________________________                        calculaFluxosMassa()    Calcula a os fluxos de massa totais da malha, com base no valor de rho*V nas fronteiras do dominio.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 11/06/07._____________________________________________________________________________________*/int calculaFluxosMassa( Grid *malha ){    // ###########################################    // OBS! So' funciona para uma malha uniforme    // ###########################################'    Cell *celula;    //int bla;    malha->M_norte = malha->M_sul = malha->M_leste = malha->M_oeste = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Percorre as celulas que sao volumes ficticios da fronteira leste do dominio        // para calcular fluxo de massa        for(celula = malha->firstGridCell->south->west;            celula->volumeFicticio == false;            celula = celula->south)        {            malha->M_leste += celula->eastFaceRho * celula->eastFaceU;        }        // Percorre as celulas que sao volumes ficticios da fronteira sul do dominio        // para calcular fluxo de massa        for(celula = celula->north;             celula->volumeFicticio == false;            celula = celula->west)        {            malha->M_sul += celula->southFaceRho * celula->southFaceV;        }        // Percorre as celulas que sao volumes ficticios da fronteira oeste do dominio        // para calcular fluxo de massa        for(celula = celula->east;             celula->volumeFicticio == false;            celula = celula->north)        {            malha->M_oeste += celula->westFaceRho * celula->westFaceU;        }        // Percorre as celulas que sao volumes ficticios da fronteira norte do dominio        // para calcular fluxo de massa        for(celula = celula->south;             celula->volumeFicticio == false;            celula = celula->east)        {            malha->M_norte += celula->northFaceRho * celula->northFaceV;        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaFluxosMassa():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaFluxosMassa():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                Funcao calculaVarVizinho()    Calcula o valor de alguma variavel correspondente a alguma direcao deuma celula, considerando niveis de refinamento diferentes.    Parametros:        celula: apontador para a direcao desejada da celula        id_variavel: um identificador para saber qual variavel esta sendo                     solicitada        levelPrincipal: nivel de refinamento da celula principal.    Criado por Henrique e Gerley dia 27/11/2007.______________________________________________________________________________*/double calculaVarVizinho( Cell *celula, short id_variavel, int &levelPrincipal ){    if( celula == NULL )    {        cout << "\nNa funcao calculaVarVizinho(): ";        IMPRIMIR_ERRO_CELULA_INEXISTENTE();        return 0.0;    }    double Var = 0.0,           S_e = 0.0,           S_w = 0.0,           S_n = 0.0,           S_s = 0.0,           uVizLeste = 0.0,           uVizOeste = 0.0,           vVizNorte = 0.0,           vVizSul = 0.0;    // Se o vizinho e' maior ou igual a celula principal, retorna o valor da variavel no vizinho    if( levelPrincipal == celula->level )    {        while( celula->type == 'w' )            celula = celula->singleConnector;        switch( id_variavel )        {            case ID_VAR_RHO:                Var = celula->rhoAtual;            break;            case ID_VAR_U:                Var = celula->uAtual;            break;            case ID_VAR_V:                Var = celula->vAtual;            break;            case ID_VAR_MI:                Var = celula->miAtual;            break;            case ID_VAR_K:                Var = celula->kAtual;            break;            case ID_VAR_P:                Var = celula->pAtual;            break;            case ID_VAR_PLINHA:                Var = celula->pLinha;            break;            case ID_VAR_T:                Var = celula->TAtual;            break;            case ID_VAR_U_ITERANTERIOR:                Var = celula->uIterAnterior;            break;            case ID_VAR_V_ITERANTERIOR:                Var = celula->vIterAnterior;            break;            case ID_VAR_TERMO_FONTE_U:     // da funcao calculaVelocidadesNasFaces()                S_e = celula->eastFaceMi * celula->eastFaceBeta / 3.0;                S_w = celula->westFaceMi * celula->westFaceBeta / 3.0;                uVizLeste = calculaVarVizinho( celula->east, ID_VAR_U, celula->level );                uVizOeste = calculaVarVizinho( celula->west, ID_VAR_U, celula->level );                Var = celula->faceLength *                        ( celula->northFaceMi * derivada('v', 'x', celula, 'n')                        - celula->southFaceMi * derivada('v', 'x', celula, 's') )                        + celula->faceLength * ( 2.0 / 3.0 )                        * ( -celula->eastFaceMi * derivada('v', 'y', celula, 'e')                        + celula->westFaceMi * derivada('v', 'y', celula, 'w') )                        + S_e * uVizLeste + S_w * uVizOeste;            break;            case ID_VAR_TERMO_FONTE_V:     // da funcao calculaVelocidadesNasFaces()                S_n = celula->northFaceMi * celula->northFaceBeta / 3.0;                S_s = celula->southFaceMi * celula->southFaceBeta / 3.0;                vVizNorte = calculaVarVizinho( celula->north, ID_VAR_V, celula->level );                vVizSul = calculaVarVizinho( celula->south, ID_VAR_V, celula->level );                Var = celula->faceLength *                        ( celula->eastFaceMi * derivada('u', 'y', celula, 'e')                        - celula->westFaceMi * derivada('u', 'y', celula, 'w') )                        + celula->faceLength * ( 2.0 / 3.0 )                        * ( -celula->northFaceMi * derivada('u', 'x', celula, 'n')                        + celula->southFaceMi * derivada('u', 'x', celula, 's') )                        + S_n * vVizNorte + S_s * vVizSul;            break;            case ID_VAR_A_P_X:        // coeficiente A_P do momento x                if( celula->firstElementMomentoX != NULL )                    Var = celula->firstElementMomentoX->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_A_P_Y:        // coeficiente A_P do momento y                if( celula->firstElementMomentoY != NULL )                    Var = celula->firstElementMomentoY->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_SOMATORIO_U_VIZINHOS:   // somatorio A_i u_i dos i vizinhos da celula                if( celula->firstElementMomentoX != NULL )                {                    Var = 0.0;                    for(Element *elementAux = celula->firstElementMomentoX->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        Var += elementAux->value * elementAux->cell->uAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_SOMATORIO_V_VIZINHOS:   // somatorio A_i v_i dos i vizinhos da celula                if( celula->firstElementMomentoY != NULL )                {                    Var = 0.0;                    for(Element *elementAux = celula->firstElementMomentoY->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        Var += elementAux->value * elementAux->cell->vAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_MASSA_ANTERIOR:                Var = celula->rhoAnterior * AO_QUADRADO( celula->faceLength );            break;            default:                cout << "\nNa funcao calculaVarVizinho(): ";                IMPRIMIR_ERRO_VAR_NAO_IMPLEMENTADA();            return 0;        }        return Var;    }    // Senao, os vizinhos sao menores que a celula pricipal. Nesse caso,    // retorna a soma dos valores da variavel em cada um de acordo com seu refinamento.    else if( celula->type == 'b' )    {        switch( id_variavel )        {            case ID_VAR_RHO:                Var = celula->rhoAtual;            break;            case ID_VAR_U:                Var = celula->uAtual;            break;            case ID_VAR_V:                Var = celula->vAtual;            break;            case ID_VAR_MI:                Var = celula->miAtual;            break;            case ID_VAR_K:                Var = celula->kAtual;            break;            case ID_VAR_P:                Var = celula->pAtual;            break;            case ID_VAR_PLINHA:                Var = celula->pLinha;            break;            case ID_VAR_T:                Var = celula->TAtual;            break;            case ID_VAR_U_ITERANTERIOR:                Var = celula->uIterAnterior;            break;            case ID_VAR_V_ITERANTERIOR:                Var = celula->vIterAnterior;            break;            case ID_VAR_TERMO_FONTE_U:     // da funcao calculaVelocidadesNasFaces()                S_e = celula->eastFaceMi * celula->eastFaceBeta / 3.0;                S_w = celula->westFaceMi * celula->westFaceBeta / 3.0;                uVizLeste = calculaVarVizinho( celula->east, ID_VAR_U, celula->level );                uVizOeste = calculaVarVizinho( celula->west, ID_VAR_U, celula->level );                Var = celula->faceLength *                        ( celula->northFaceMi * derivada('v', 'x', celula, 'n')                        - celula->southFaceMi * derivada('v', 'x', celula, 's') )                        + celula->faceLength * ( 2.0 / 3.0 )                        * ( -celula->eastFaceMi * derivada('v', 'y', celula, 'e')                        + celula->westFaceMi * derivada('v', 'y', celula, 'w') )                        + S_e * uVizLeste + S_w * uVizOeste;            break;            case ID_VAR_TERMO_FONTE_V:     // da funcao calculaVelocidadesNasFaces()                S_n = celula->northFaceMi * celula->northFaceBeta / 3.0;                S_s = celula->southFaceMi * celula->southFaceBeta / 3.0;                vVizNorte = calculaVarVizinho( celula->north, ID_VAR_V, celula->level );                vVizSul = calculaVarVizinho( celula->south, ID_VAR_V, celula->level );                Var = celula->faceLength *                        ( celula->eastFaceMi * derivada('u', 'y', celula, 'e')                        - celula->westFaceMi * derivada('u', 'y', celula, 'w') )                        + celula->faceLength * ( 2.0 / 3.0 )                        * ( -celula->northFaceMi * derivada('u', 'x', celula, 'n')                        + celula->southFaceMi * derivada('u', 'x', celula, 's') )                        + S_n * vVizNorte + S_s * vVizSul;            break;            case ID_VAR_A_P_X:        // coeficiente A_P do momento x                if( celula->firstElementMomentoX != NULL )                    Var = celula->firstElementMomentoX->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_A_P_Y:        // coeficiente A_P do momento y                if( celula->firstElementMomentoY != NULL )                    Var = celula->firstElementMomentoY->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_SOMATORIO_U_VIZINHOS:   // somatorio A_i u_i dos i vizinhos da celula                if( celula->firstElementMomentoX != NULL )                {                    Var = 0.0;                    for(Element *elementAux = celula->firstElementMomentoX->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        Var += elementAux->value * elementAux->cell->uAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_SOMATORIO_V_VIZINHOS:   // somatorio A_i v_i dos i vizinhos da celula                if( celula->firstElementMomentoY != NULL )                {                    Var = 0.0;                    for(Element *elementAux = celula->firstElementMomentoY->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        Var += elementAux->value * elementAux->cell->vAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVarVizinho()" << endl;                    return ERRO_ELEMENT_NULO;                }            break;            case ID_VAR_MASSA_ANTERIOR:                Var = celula->rhoAnterior * AO_QUADRADO( celula->faceLength );            break;            default:                cout << "\nNa funcao calculaVarVizinho(): ";                IMPRIMIR_ERRO_VAR_NAO_IMPLEMENTADA();            return 0;        }        return Var / pow(2, celula->level - levelPrincipal);    }    else    {        return calculaVarVizinho( celula->doubleConnector1, id_variavel, levelPrincipal ) +               calculaVarVizinho( celula->doubleConnector2, id_variavel, levelPrincipal );    }}/*______________________________________________________________________________                Funcao insereCoeficientesVizinho()    insere o coeficiente dos vizinhos correspondente a alguma direcao de    uma celula, considerando niveis de refinamento diferentes.    Parametros:        celula: apontador para a direcao desejada da celula        id_variavel: um identificador para saber qual variavel esta sendo                     solicitada        levelPrincipal: nivel de refinamento da celula principal.    Criado por Henrique e Gerley dia 27/11/2007.________________________________________________________________________________*/void insereCoeficientesVizinho(Cell *celulaPrincipal, Cell *celulaViz,                                double coeficiente, short id_variavel ){    if( celulaViz == NULL )    {        cout << "Erro na funcao insereCoeficientesVizinho() [1]:" << endl;        IMPRIMIR_ERRO_CELULA_INEXISTENTE();        return;    }    if( celulaPrincipal == NULL )    {        cout << "Erro na funcao insereCoeficientesVizinho() [2]:" << endl;        IMPRIMIR_ERRO_CELULA_INEXISTENTE();        return;    }    if( id_variavel != ID_VAR_U    &&  id_variavel != ID_VAR_V    &&  id_variavel != ID_VAR_PLINHA    &&  id_variavel != ID_VAR_T )    {        cout << "Erro na funcao insereCoeficientesVizinho() [3]:" << endl;        IMPRIMIR_ERRO_VAR_NAO_IMPLEMENTADA();        return;    }        // Se o vizinho e' maior ou igual a celula principal, insere o coeficiente do vizinho    if( celulaPrincipal->level == celulaViz->level )    {        while( celulaViz->type == 'w' )            celulaViz = celulaViz->singleConnector;        switch( id_variavel )        {            case ID_VAR_U:                celulaPrincipal->insereElement( coeficiente, celulaViz,                                                 &(celulaPrincipal->firstElementMomentoX) );            break;            case ID_VAR_V:                celulaPrincipal->insereElement( coeficiente, celulaViz,                                                 &(celulaPrincipal->firstElementMomentoY) );            break;            case ID_VAR_PLINHA:                celulaPrincipal->insereElement( coeficiente, celulaViz,                                                 &(celulaPrincipal->firstElementPressaoLinha) );            break;            case ID_VAR_T:                celulaPrincipal->insereElement( coeficiente, celulaViz,                                                 &(celulaPrincipal->firstElementEnergia) );            break;        }    }    // Senao, os vizinhos sao menores que a celula pricipal. Nesse caso,    // insere os coeficientes de cada vizinho de acordo com seu refinamento.    else if( celulaViz->type == 'b' )    {        switch( id_variavel )        {            case ID_VAR_U:                celulaPrincipal->insereElement( coeficiente /                                                    pow(2, celulaViz->level - celulaPrincipal->level),                                                    celulaViz, &(celulaPrincipal->firstElementMomentoX) );            break;            case ID_VAR_V:                celulaPrincipal->insereElement( coeficiente /                                                    pow(2, celulaViz->level - celulaPrincipal->level),                                                    celulaViz, &(celulaPrincipal->firstElementMomentoY) );            break;            case ID_VAR_PLINHA:                celulaPrincipal->insereElement( coeficiente /                                                    pow(2, celulaViz->level - celulaPrincipal->level),                                                    celulaViz, &(celulaPrincipal->firstElementPressaoLinha) );            break;            case ID_VAR_T:                celulaPrincipal->insereElement( coeficiente /                                                    pow(2, celulaViz->level - celulaPrincipal->level),                                                    celulaViz, &(celulaPrincipal->firstElementEnergia) );            break;          }            }    else    {        insereCoeficientesVizinho(celulaPrincipal, celulaViz->doubleConnector1, coeficiente, id_variavel );        insereCoeficientesVizinho(celulaPrincipal, celulaViz->doubleConnector2, coeficiente, id_variavel );    }}/*______________________________________________________________________________                  atualizaParametrosDaIteracaoAnterior()   Atualiza parametros no inicio de cada iteracaopara a verificacao do criterio   de convergencia ao final da mesma.   Parametros:       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 25/04/07.Atualizado por Henrique dia 12/06/07.______________________________________________________________________________*/int atualizaParametrosDaIteracaoAnterior( Grid *malha, char ciclo ){    Cell *celula;    if( ciclo != 'A'    &&  ciclo != 'B'    &&  ciclo != 'C' )    {        cout << "Erro ciclo inexistente\n";        return INSUCESSO;    }    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for( celula = malha->firstGridCell;             celula != NULL;             celula = celula->next)        {            if( celula->active )            {                // atualiza parametros                if( ciclo == 'A' )                {                    celula->TIterAnterior = celula->TAtual;                }                else if( ciclo == 'B' )                {                    celula->uIterAnterior = celula->uAtual;                    celula->vIterAnterior = celula->vAtual;                }                else if( ciclo == 'C' )                {                    celula->pIterAnterior = celula->pAtual;                }            }        }        return SUCESSO;    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em atualizaParametrosDaIteracaoAnterior()" << endl;        return ERRO_MALHA_VAZIA;    }    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    cout << "Erro acima ocorreu em atualizaParametrosDaIteracaoAnterior()" << endl;    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  atualizaParametrosDoTempoAnterior()   Atualiza parametros para prosseguir em um proximo passo de tempo.   Parametros:       malha: apontador para a malha em questao;Criado por Andre STALTZ dia 08/05/07______________________________________________________________________________*/int atualizaParametrosDoTempoAnterior( Grid *malha ){    Cell *celula;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for( celula = malha->firstGridCell;             celula != NULL;             celula = celula->next)        {            if( celula->active )            {                // Atualiza parametros                celula->uRetrasado = celula->uAnterior;                celula->uAnterior = celula->uAtual;                celula->eastFaceURetrasado = celula->eastFaceUAnterior;                celula->eastFaceUAnterior = celula->eastFaceU;                celula->westFaceURetrasado = celula->westFaceUAnterior;                celula->westFaceUAnterior = celula->westFaceU;                celula->vRetrasado = celula->vAnterior;                celula->vAnterior = celula->vAtual;                celula->northFaceVRetrasado = celula->northFaceVAnterior;                celula->northFaceVAnterior = celula->northFaceV;                celula->southFaceVRetrasado = celula->southFaceVAnterior;                celula->southFaceVAnterior = celula->southFaceV;                celula->pRetrasado = celula->pAnterior;                celula->pAnterior = celula->pAtual;                celula->rhoRetrasado = celula->rhoAnterior;                celula->rhoAnterior = celula->rhoAtual;                celula->TRetrasado = celula->TAnterior;                celula->TAnterior = celula->TAtual;                celula->PhiRetrasado = celula->PhiAnterior;                celula->PhiAnterior = celula->PhiAtual;                celula->miRetrasado = celula->miAnterior;                celula->miAnterior = celula->miAtual;                celula->kAnterior = celula->kAtual;            }        }        return SUCESSO;    }    else    {        cout << "Na funcao atualizaParametrosDoTempoAnterior():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao atualizaParametrosDoTempoAnterior():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                        calculaResiduos()    Calcula os residuos das variaveis importantes para desenhar seus graficos.Residuo de uma equacao = || A x - b ||, para alguma norma.______________________________________________________________________________*/void calculaResiduos( Grid *malha, int iteracaoAtual ){    Cell *celula; // Celula da malha    double residuoU = 0.0,           residuoUdaCelula = 0.0,           residuoV = 0.0,           residuoVdaCelula = 0.0,           residuoMassa = 0.0,           residuoP = 0.0,           residuoPdaCelula = 0.0,           residuoE = 0.0,           residuoEdaCelula = 0.0;    Element *aux;    if(malha->firstGridCell != NULL)    {        // Calcula os erros de todas as celulas ativas da malha        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if(celula->volumeFicticio == false && celula->active == true)            {                // Momento x ===================================================                aux = celula->firstElementMomentoX;                if( !aux )                    return;                // Somando A_P u_P                residuoUdaCelula = aux->value * celula->uAtual;                // Somando A_viz u_viz                aux = aux->next;                while( aux )                {                    residuoUdaCelula += aux->value * aux->cell->uAtual;                    aux = aux->next;                }                // Subtraindo membro direito                residuoUdaCelula -= celula->b_MomentoX;                // Para fazer a norma 2                residuoU += AO_QUADRADO(residuoUdaCelula);                // Momento y ===================================================                aux = celula->firstElementMomentoY;                if( !aux )                    return;                // Somando A_P v_P                residuoVdaCelula = aux->value * celula->vAtual;                // Somando A_viz v_viz                aux = aux->next;                while( aux )                {                    residuoVdaCelula += aux->value * aux->cell->vAtual;                    aux = aux->next;                }                // Subtraindo membro direito                residuoVdaCelula -= celula->b_MomentoY;                // Para fazer a norma 2                residuoV += AO_QUADRADO(residuoVdaCelula);                // Correcao de pressao =====================================                aux = celula->firstElementPressaoLinha;                if( !aux )                    return;                // Soma A_P u_P                residuoPdaCelula = aux->value * celula->pLinha;                // Soma A_viz u_viz                aux = aux->next;                while( aux  )                {                    residuoPdaCelula += aux->value * aux->cell->pLinha;                    aux = aux->next;                }                // Subtrai o membro direito                residuoPdaCelula -= celula->b_PressaoLinha;                // Para fazer a norma 2                residuoP += AO_QUADRADO(residuoPdaCelula);                //Energia =======================================================                aux = celula->firstElementEnergia;                if( !aux )                    return;                //somando F_P T_P                residuoEdaCelula = aux->value * celula->TAtual;                //soma F_vizinhos e T_Vizinhos                aux = aux->next;                while( aux )                {                    residuoEdaCelula += aux->value * aux->cell->TAtual;                    aux = aux->next;                }                //subtraindo membro da direita                residuoEdaCelula -= celula->b_Energia;                // Para fazer a norma 2                residuoE += AO_QUADRADO(residuoEdaCelula);                // Massa ===============================================================                residuoMassa += AO_QUADRADO((celula->rhoAtual - celula->rhoAnterior) *                                    AO_QUADRADO(celula->faceLength) / malha->deltaT +                                    (celula->eastFaceRho * celula->eastFaceU -                                     celula->westFaceRho * celula->westFaceU +                                     celula->northFaceRho * celula->northFaceV -                                     celula->southFaceRho * celula->southFaceV)                                    * celula->faceLength);            }        }        // Calcula os erros de cada equacao        malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoP);        malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoU);        malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoV);        malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoE);        malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoMassa);        // Atualiza maior residuo        if(malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        // Atualiza menor residuo        if(malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }    }    else    {        cout << "Na funcao calculaResiduos():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return;    }}/*______________________________________________________________________________                  atualizaPassoTempo()   Atualiza deltaT para evitar possiveis divergencias, buscando um deltaT maisseguro. Se começou a divergir, ele volta no tempo e prepara para recalcular comnovo deltaT.   Parametros:       malha: apontador para a malha em questao;______________________________________________________________________________*/int atualizaPassoTempo( Grid *malha, int iteracaoAtual ){    Cell *celula;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        if(malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > COTA_RESIDUO_PARA_DIMINUIR_DELTAT)        {            // Volta no tempo            // Para cada celula da malha            for( celula = malha->firstGridCell;                 celula != NULL;                 celula = celula->next)            {                if( celula->active )                {                    celula->rhoAtual = celula->rhoAnterior;                    celula->rhoAnterior = celula->rhoRetrasado;                    celula->uAtual = celula->uAnterior;                    celula->uAnterior = celula->uRetrasado;                    celula->vAtual = celula->vAnterior;                    celula->vAnterior = celula->vRetrasado;                    celula->TAtual = celula->TAnterior;                    celula->TAnterior = celula->TRetrasado;                    celula->PhiAtual = celula->PhiAnterior;                    celula->PhiAnterior = celula->PhiRetrasado;                    celula->pAtual = celula->pAnterior;                    celula->pAnterior = celula->pRetrasado;                    celula->miAtual = celula->miAnterior;                    celula->miAnterior = celula->miRetrasado;                    celula->kAtual = celula->kAnterior;                    celula->eastFaceU = celula->eastFaceUAnterior;                    celula->eastFaceUAnterior = celula->eastFaceURetrasado;                    celula->westFaceU = celula->westFaceUAnterior;                    celula->westFaceUAnterior = celula->westFaceURetrasado;                    celula->northFaceV = celula->northFaceVAnterior;                    celula->northFaceVAnterior = celula->northFaceVRetrasado;                    celula->southFaceV = celula->southFaceVAnterior;                    celula->southFaceVAnterior = celula->southFaceVRetrasado;                }            }            // Diminui deltaT            malha->deltaT /= 2.0;        }        else if(malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < COTA_RESIDUO_PARA_AUMENTAR_DELTAT)        {            // Aumentar deltaT            malha->deltaT *= 2.0;        }        return SUCESSO;    }    else    {        cout << "Na funcao atualizaPassoTempo():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao atualizaPassoTempo():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}