/*  ============= pressao.cpp ==============    Contem funcoes para resolver as equacoes    de correcao de pressao no SIMPLE.*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                   calculaCoeficientesCorrecaoPressao()    Calcula os coeficientes L_p, L_e, L_w, L_n, L_s para cada celula,montando a matriz [A] do sistema associado 'a correcao de pressao.    Parametros:        malha: apontador para a malha em questao;Criado por Andre STALTZ dia 31/03/07.______________________________________________________________________________*/int calculaCoeficientesCorrecaoPressao( Grid *malha ){    Cell *celula;    short tipoFronteira;    // Declaracao dos fatores inclusos nos coeficientes    double m_P_rho = 0.0,           m_e_rho = 0.0,           m_w_rho = 0.0,           m_n_rho = 0.0,           m_s_rho = 0.0;    double m_e_u = 0.0,           m_w_u = 0.0,           m_n_v = 0.0,           m_s_v = 0.0;    double C_P_rho = 0.0,           C_E_rho = 0.0,           C_W_rho = 0.0,           C_N_rho = 0.0,           C_S_rho = 0.0;    double L_P = 0.0,           L_e = 0.0,           L_w = 0.0,           L_n = 0.0,           L_s = 0.0;    double rhoVizLeste = 0.0,           rhoVizOeste = 0.0,           rhoVizNorte = 0.0,           rhoVizSul = 0.0;    double TVizLeste = 0.0,           TVizOeste = 0.0,           TVizNorte = 0.0,           TVizSul = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Evitar caso especial dos quatro cantos ficticios: nao entram no sistema            if( celula->active )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_PLINHA );                // Volume ficticio (fronteira oeste)                if( celula->direcaoFronteira == FRONTEIRA_OESTE && celula->volumeFicticio == true )                {                    // Se no OESTE for prescrito                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Coeficientes importantes para condicao dirichlet                        L_P = 1.0;                        L_e = 1.0;                        // Outros coeficientes                        L_w = 0.0; L_n = 0.0; L_s = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_PressaoLinha = 2.0 * valorCondicaoFronteira( celula->east, ID_VAR_PLINHA, 'w');                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no oeste!" << endl;                    }                }                // Volume ficticio (fronteira leste)                else if( celula->direcaoFronteira == FRONTEIRA_LESTE && celula->volumeFicticio == true )                {                    // Se o LESTE for extrapolado                    if(tipoFronteira == CONDICAO_FRONTEIRA_EXTRAPOLADA)                    {                        // Fronteira impermeavel, coeficientes importantes                        L_P = 1.0;                        L_w = -1.0;                        // Outros coeficientes                        L_e = 0.0; L_n = 0.0; L_s = 0.0;                        celula->b_PressaoLinha = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no leste!" << endl;                    }                }                // Volume ficticio (fronteira norte)                else if( celula->direcaoFronteira == FRONTEIRA_NORTE && celula->volumeFicticio == true )                {                    // Se no NORTE for prescrito                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Coeficientes importantes para condicao dirichlet                        L_P = 1.0;                        L_s = 1.0;                        // Outros coeficientes                        L_w = 0.0; L_n = 0.0; L_e = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_PressaoLinha = 2.0 * valorCondicaoFronteira( celula->south, ID_VAR_PLINHA, 'n');                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no norte!" << endl;                    }                }                // Volume ficticio (fronteira sul)                else if( celula->direcaoFronteira == FRONTEIRA_SUL && celula->volumeFicticio == true )                {                    // Se o SUL for extrapolado                    if(tipoFronteira == CONDICAO_FRONTEIRA_EXTRAPOLADA)                    {                        // Fronteira impermeavel, coeficientes importantes                        L_P = 1.0;                        L_n = -1.0;                        // Outros coeficientes                        L_e = 0.0; L_w = 0.0; L_s = 0.0;                        celula->b_PressaoLinha = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no sul!" << endl;                    }                }                // Volumes internos                else                {                    rhoVizNorte = calculaVarVizinho( celula->north, ID_VAR_RHO, celula->level );                    rhoVizSul   = calculaVarVizinho( celula->south, ID_VAR_RHO, celula->level );                    rhoVizLeste = calculaVarVizinho( celula->east, ID_VAR_RHO, celula->level );                    rhoVizOeste = calculaVarVizinho( celula->west, ID_VAR_RHO, celula->level );                    TVizNorte = calculaVarVizinho( celula->north, ID_VAR_T, celula->level );                    TVizSul   = calculaVarVizinho( celula->south, ID_VAR_T, celula->level );                    TVizLeste = calculaVarVizinho( celula->east, ID_VAR_T, celula->level );                    TVizOeste = calculaVarVizinho( celula->west, ID_VAR_T, celula->level );                    // Fator m_(P,e,w,n,s)_rho que depende de (u,v)_(e,w,n,s)^* e os gammas ---                    m_P_rho = (celula->faceLength / malha->deltaT) * celula->faceLength                            + celula->faceLength                            *(                                 (0.5 + celula->eastFaceGamma) * celula->eastFaceU                                -(0.5 - celula->westFaceGamma) * celula->westFaceU                                +(0.5 + celula->northFaceGamma) * celula->northFaceV                                -(0.5 - celula->southFaceGamma) * celula->southFaceV                             );                    m_e_rho = celula->faceLength * celula->eastFaceU                            * (0.5 - celula->eastFaceGamma);                    m_w_rho = -1.0 * celula->faceLength * celula->westFaceU                            * (0.5 + celula->westFaceGamma);                    m_n_rho = celula->faceLength * celula->northFaceV                            * (0.5 - celula->northFaceGamma);                    m_s_rho = -1.0 * celula->faceLength * celula->southFaceV                            * (0.5 + celula->southFaceGamma);                    // Fator C_(P,E,W,N,S)_rho que depende da temperatura e da equacao de estado                    C_P_rho = 1.0 / (R * celula->TAtual);                    C_E_rho = 1.0 / (R * TVizLeste);                    C_W_rho = 1.0 / (R * TVizOeste);                    C_N_rho = 1.0 / (R * TVizNorte);                    C_S_rho = 1.0 / (R * TVizSul);                    // Fatores m_(e,w,n,s)^(u,v) que dependem de rho_(E,W,N,S)^* e os gammas                    m_e_u = celula->faceLength                            *(                                (0.5 + celula->eastFaceGamma) * celula->rhoAtual                                +(0.5 - celula->eastFaceGamma) * rhoVizLeste                             );                    m_w_u = -1.0 * celula->faceLength                            *(                                (0.5 + celula->westFaceGamma) * rhoVizOeste                                +(0.5 - celula->westFaceGamma) * celula->rhoAtual                             );                    m_n_v = celula->faceLength                            *(                                (0.5 + celula->northFaceGamma) * celula->rhoAtual                                +(0.5 - celula->northFaceGamma) * rhoVizNorte                             );                    m_s_v = -1.0 * celula->faceLength                            *(                                (0.5 + celula->southFaceGamma) * rhoVizSul                                +(0.5 - celula->southFaceGamma) * celula->rhoAtual                             );                    // Fatores d_(e,w,n,s) que dependem de I_(e,w,n,s), dado pelo parametro                    // OBS: FOI EVITADA A DIVISAO POR ZERO, MAS ISTO E' QUESTIONAVEL                    celula->d_e = ( (celula->I_e == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_e) );                    celula->d_w = ( (celula->I_w == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_w) );                    celula->d_n = ( (celula->I_n == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_n) );                    celula->d_s = ( (celula->I_s == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_s) );                    // Calcula L_P ==================================================                    L_P =   m_P_rho * C_P_rho                            + m_e_u * celula->d_e                            - m_w_u * celula->d_w                            + m_n_v * celula->d_n                            - m_s_v * celula->d_s;                    // Calcula L_(e,w,n,s) ===========================================                    L_e = -1.0 * (-1.0 * m_e_rho * C_E_rho + m_e_u * celula->d_e);                    L_w = -1.0 * (-1.0 * m_w_rho * C_W_rho - m_w_u * celula->d_w);                    L_n = -1.0 * (-1.0 * m_n_rho * C_N_rho + m_n_v * celula->d_n);                    L_s = -1.0 * (-1.0* m_s_rho * C_S_rho - m_s_v * celula->d_s);                }                /* Adicionar L_P na matriz de coeficientes de pressao */                celula->iniciaElement( L_P, &(celula->firstElementPressaoLinha) );                // Insere coeficientes dos vizinhos na mesma lista encadeada                if(celula->direcaoFronteira != FRONTEIRA_NORTE)                    insereCoeficientesVizinho(celula, celula->north, L_n, ID_VAR_PLINHA);                if(celula->direcaoFronteira != FRONTEIRA_SUL)                    insereCoeficientesVizinho(celula, celula->south, L_s, ID_VAR_PLINHA);                if(celula->direcaoFronteira != FRONTEIRA_LESTE)                    insereCoeficientesVizinho(celula, celula->east,  L_e, ID_VAR_PLINHA);                if(celula->direcaoFronteira != FRONTEIRA_OESTE)                    insereCoeficientesVizinho(celula, celula->west,  L_w, ID_VAR_PLINHA);            }        }                return SUCESSO;    }    else    {        cout << "Na funcao calculaCoeficientesCorrecaoPressao():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaCoeficientesCorrecaoPressao():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaTermoFonteCorrecaoPressao()    Calcula o termo fonte b^(P') da equacao de correcao de pressao usando asvelocidades u* e v* que acabaram de ser calculados na etapa anterior. Esse termoe' somado na matriz [B] do sistema associado a correcao de pressao.    Parametros:        malha: apontador para a malha em questao;Criado por Andre STALTZ dia 31/03/07______________________________________________________________________________*/int calculaTermoFonteCorrecaoPressao( Grid *malha ){    Cell *celula;    // Declaracao dos fatores inclusos no termo fonte    double m_P_rho = 0.0,           m_e_rho = 0.0,           m_w_rho = 0.0,           m_n_rho = 0.0,           m_s_rho = 0.0;    double rhoVizLeste = 0.0,           rhoVizOeste = 0.0,           rhoVizNorte = 0.0,           rhoVizSul = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Volumes internos            if( celula->volumeFicticio == false )            {                    rhoVizNorte = calculaVarVizinho( celula->north, ID_VAR_RHO, celula->level );                    rhoVizSul   = calculaVarVizinho( celula->south, ID_VAR_RHO, celula->level );                    rhoVizLeste = calculaVarVizinho( celula->east, ID_VAR_RHO, celula->level );                    rhoVizOeste = calculaVarVizinho( celula->west, ID_VAR_RHO, celula->level );                // Fator m_(P,e,w,n,s)_rho que depende de (u,v)_(e,w,n,s)^* e os gammas ---                m_P_rho = AO_QUADRADO( celula->faceLength ) / malha->deltaT                        + celula->faceLength                        *(                            (0.5 + celula->eastFaceGamma) * celula->eastFaceU                           -(0.5 - celula->westFaceGamma) * celula->westFaceU                           +(0.5 + celula->northFaceGamma) * celula->northFaceV                           -(0.5 - celula->southFaceGamma) * celula->southFaceV                        );                m_e_rho = celula->faceLength * celula->eastFaceU                        * (0.5 - celula->eastFaceGamma);                m_w_rho = -1.0 * celula->faceLength * celula->westFaceU                        * (0.5 + celula->westFaceGamma);                m_n_rho = celula->faceLength * celula->northFaceV                        * (0.5 - celula->northFaceGamma);                m_s_rho = -1.0 * celula->faceLength * celula->southFaceV                        * (0.5 + celula->southFaceGamma);                celula->b_PressaoLinha = celula->rhoAnterior *                                         ( AO_QUADRADO( celula->faceLength ) / malha->deltaT )                                       - m_P_rho * celula->rhoAtual                                       - m_e_rho * rhoVizLeste                                       - m_w_rho * rhoVizOeste                                       - m_n_rho * rhoVizNorte                                       - m_s_rho * rhoVizSul;            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaTermoFonteCorrecaoPressao():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaTermoFonteCorrecaoPressao():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                corrige_Velocidades_Densidades_Pressoes()    Corrige os valores das velocidades em todas as interfaces da malha, usando acorrecao de pressao, atraves de media das velocidades anteriores ponderadaspelos respectivos coeficientes na matriz. Em seguida, atraves de uma mediaaritmetica, obtem os novos valores de velocidade nos centros das celulas.    Corrige tambem os valores das densidades em todas as celulas da malha,atraves da equacao de estado e, por ultimo, calcula um novo campo de pressoes.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 08/05/07______________________________________________________________________________*/int corrige_Velocidades_Densidades_Pressoes( Grid *malha, double relaxamentoP = 1.0,                                             double relaxamentoU = 1.0, double relaxamentoV = 1.0 ){    // Celula da malha    Cell *celula;    short tipoFronteira;    double pLinha_E = 0.0,           pLinha_W = 0.0,           pLinha_N = 0.0,           pLinha_S = 0.0;    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Correcao para os volumes internos            if( celula->active && celula->volumeFicticio == false )            {                // Corrige velocidade u na interface leste da celula atual                // Se nao esta na fronteira leste                if( !verificaVizFicticio( celula->east, celula->level ) )                {                    pLinha_E = calculaVarVizinho( celula->east, ID_VAR_PLINHA, celula->level );                    celula->eastFaceU -= relaxamentoU * celula->d_e                                        * ( pLinha_E - celula->pLinha );                }                // Corrige velocidade u na interface oeste da celula atual                // Se nao esta na fronteira oeste                if( !verificaVizFicticio( celula->west, celula->level ) )                {                    pLinha_W = calculaVarVizinho( celula->west, ID_VAR_PLINHA, celula->level );                    celula->westFaceU -= relaxamentoU * celula->d_w                                        * ( celula->pLinha - pLinha_W );                }                // Corrige velocidade v na interface norte da celula atual                // Se nao esta na fronteira norte                if( !verificaVizFicticio( celula->north, celula->level ) )                {                    pLinha_N = calculaVarVizinho( celula->north, ID_VAR_PLINHA, celula->level );                    celula->northFaceV -= relaxamentoV * celula->d_n                                         * ( pLinha_N - celula->pLinha );                }                // Corrige velocidade v na interface sul da celula atual                // Se nao esta na fronteira sul                if( !verificaVizFicticio( celula->south, celula->level ) )                {                    pLinha_S = calculaVarVizinho( celula->south, ID_VAR_PLINHA, celula->level );                    celula->southFaceV -= relaxamentoV * celula->d_s                                         * ( celula->pLinha - pLinha_S );                }                // Corrige as velocidades no centro da celula atraves de media das interfaces                celula->uAtual = ( celula->eastFaceU + celula->westFaceU ) / 2.0;                celula->vAtual = ( celula->northFaceV + celula->southFaceV ) / 2.0;                // Finalmente, corrige a pressao no centro da celula atual                if( !verificaVizFicticio( celula->north, celula->level ) ) // fixando pressao de referencia                     celula->pAtual += relaxamentoP * celula->pLinha;                // Corrige a densidade no centro da celula atual                celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );            }            //========================== FICTICIO LESTE ==============================            else if( celula->direcaoFronteira == FRONTEIRA_LESTE )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );                // Se no LESTE for saida de massa                if(tipoFronteira == CONDICAO_FRONTEIRA_SAIDA_MASSA)                {                    double uOeste =                        calculaVarVizinho( celula->west, ID_VAR_U, celula->level );                    double uOesteIterAnterior =                        calculaVarVizinho( celula->west, ID_VAR_U_ITERANTERIOR, celula->level );                    double vOeste =                        calculaVarVizinho( celula->west, ID_VAR_V, celula->level );                    double vOesteIterAnterior =                        calculaVarVizinho( celula->west, ID_VAR_V_ITERANTERIOR, celula->level );                    // u no leste                    celula->uAtual += (uOeste - uOesteIterAnterior);                    // v no leste                    celula->vAtual += (vOeste - vOesteIterAnterior);                }                // Imprime erro de programacao                else                {                    cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                        << "Tipo de fronteira " << tipoFronteira                        << " nao implementado no leste!" << endl;                }              //  celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );              //  celula->pAtual += celula->pLinha;                celula->uAtual =  relaxamentoU * celula->uAtual                                + (1.0 - relaxamentoU) * celula->uIterAnterior;                celula->vAtual =  relaxamentoV * celula->vAtual                                + (1.0 - relaxamentoV) * celula->vIterAnterior;                // densidade no leste                celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );                // pressao no leste                celula->pAtual += relaxamentoP * celula->pLinha;            }            //========================== FICTICIO SUL ==============================            else if( celula->direcaoFronteira == FRONTEIRA_SUL )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );                // Se no SUL for prescrito                if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                {                    double uNorte =                        calculaVarVizinho( celula->north, ID_VAR_U, celula->level );                    double uNorteIterAnterior =                        calculaVarVizinho( celula->north, ID_VAR_U_ITERANTERIOR, celula->level );                    double vNorte =                         calculaVarVizinho( celula->north, ID_VAR_V, celula->level );                    double vNorteIterAnterior =                         calculaVarVizinho( celula->north, ID_VAR_V_ITERANTERIOR, celula->level );                    // u no sul                    celula->uAtual -= (uNorte - uNorteIterAnterior);                    // v no sul                    celula->vAtual -= (vNorte - vNorteIterAnterior);                }                // Imprime erro de programacao                else                {                    cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                            << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no sul!" << endl;                }               // celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );               // celula->pAtual += celula->pLinha;                celula->uAtual =  relaxamentoU * celula->uAtual                                + (1.0 - relaxamentoU) * celula->uIterAnterior;                celula->vAtual =  relaxamentoV * celula->vAtual                                + (1.0 - relaxamentoV) * celula->vIterAnterior;                // densidade no sul                celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );                // pressao no sul                celula->pAtual += relaxamentoP * celula->pLinha;            }            //========================== FICTICIO OESTE ==============================            else if( celula->direcaoFronteira == FRONTEIRA_OESTE )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );                // Se no OESTE for prescrito                if(tipoFronteira == CONDICAO_FRONTEIRA_ENTRADA_MASSA)                {                    // u no oeste                    //celula->uAtual += 0.0; // comentado para evitar esforco inutil                    // v no oeste                    //celula->vAtual += 0.0; // comentado para evitar esforco inutil                    //celula->uAtual =  relaxamentoU * celula->uAtual // comentado para evitar esforco inutil                    //            + (1.0 - relaxamentoU) * celula->uIterAnterior;                    //celula->vAtual =  relaxamentoV * celula->vAtual // comentado para evitar esforco inutil                    //                + (1.0 - relaxamentoV) * celula->vIterAnterior;                }                // Imprime erro de programacao                else                {                    cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                            << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no oeste!" << endl;                }             //   celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );             //   celula->pAtual += celula->pLinha;                // densidade no oeste                celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );                // pressao no oeste                celula->pAtual += relaxamentoP * celula->pLinha;            }            //========================== FICTICIO NORTE ==============================            else if( celula->direcaoFronteira == FRONTEIRA_NORTE )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );                // Se no NORTE for prescrito                if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                {                    double uSul =                         calculaVarVizinho( celula->south, ID_VAR_U, celula->level );                    double uSulIterAnterior =                         calculaVarVizinho( celula->south, ID_VAR_U_ITERANTERIOR, celula->level );                    double vSul =                        calculaVarVizinho( celula->south, ID_VAR_V, celula->level );                    double vSulIterAnterior =                         calculaVarVizinho( celula->south, ID_VAR_V_ITERANTERIOR, celula->level );                    // u no norte                    celula->uAtual -= (uSul - uSulIterAnterior);                    // v no norte                    celula->vAtual -= (vSul - vSulIterAnterior);                    celula->uAtual =  relaxamentoU * celula->uAtual                                     + (1.0 - relaxamentoU) * celula->uIterAnterior;                    celula->vAtual =  relaxamentoV * celula->vAtual                                    + (1.0 - relaxamentoV) * celula->vIterAnterior;                }                // Imprime erro de programacao                else                {                    cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                            << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no norte!" << endl;                }               // celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );               // celula->pAtual += celula->pLinha;                // densidade no norte                celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );                // pressao no norte                celula->pAtual += relaxamentoP * celula->pLinha;            }        }        return SUCESSO;    }    else    {        cout << "Na funcao corrige_Velocidades_Densidades_Pressoes():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao corrige_Velocidades_Densidades_Pressoes():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  convergenciaPressao()   Verifica a convergencia das pressoes.   Parametros:       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 25/04/07.Atualizado por Henrique dia 09/07/09.______________________________________________________________________________*/int convergenciaPressao( Grid *malha ){    Cell *celula; // Celula da malha    double deltaP = 0.0,           maiorDeltaP = 0.0,           maiorP = 0.0,           menorP = 10.0 * PRESSAO_LIVRE,           erroPressao = 0.0;    if(malha->firstGridCell != NULL)    {        // Calcula os erros na pressao de todas as celulas ativas        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if(celula->volumeFicticio == false && celula->active == true)            {                deltaP = fabs(celula->pAtual - celula->pIterAnterior);                if(deltaP > maiorDeltaP)                    maiorDeltaP = deltaP;                if(celula->pAtual > maiorP)                    maiorP = celula->pAtual;                if(celula->pAtual < menorP)                    menorP = celula->pAtual;            }        }        // Calcula o erro na pressao        if((maiorP - menorP) != 0.0)            erroPressao = maiorDeltaP / (maiorP - menorP);        else        {            erroPressao = maiorDeltaP;        }        // Verifica convergencia e retorna resultado        if ( erroPressao < COTA_PRESSAO )            return SUCESSO;        else{            cout << "erroPressao = " << erroPressao << endl;            return INSUCESSO;        }    }    else    {        cout << "Na funcao convergenciaPressao():\n";         IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }}