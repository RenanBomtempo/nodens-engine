/*  ========== momento.cpp =========    Contem funcoes para resolver as equacoes do momento    de Navier-Stokes*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                   calculaCoeficientesMomento()    Calcula os coeficientes A_p, A_e, A_w, A_n, A_s dos momentos x e y para cadacelula, montando as matrizes dos sistemas associados aos momentos x e y.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 19/11/07.______________________________________________________________________________*/int calculaCoeficientesMomento( Grid *malha ){    // Obs: Todos os deltaY/deltaX da discretizacao foram substituidos por 1,    // visto que a malha do ALG e' sempre quadrada    // Obs: Variaveis nas faces (mi, rho, u) PRECISAM ser os "*" (estimados)    Cell *celula;    short tipoFronteira;    // Coeficientes    double A_P_x = 0.0,           A_e_x = 0.0,           A_w_x = 0.0,           A_n_x = 0.0,           A_s_x = 0.0,           A_P_y = 0.0,           A_e_y = 0.0,           A_w_y = 0.0,           A_n_y = 0.0,           A_s_y = 0.0;    double S_P_x = 0.0,           S_P_y = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Evitar caso especial dos quatro cantos ficticios: nao entram no sistema            if( celula->active )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );                // Volume ficticio (fronteira oeste)                if( celula->direcaoFronteira == FRONTEIRA_OESTE && celula->volumeFicticio == true )                {                    // Se no OESTE for entrada de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_ENTRADA_MASSA)                    {                        // Momento x                        A_P_x = 1.0;                        A_e_x = 0.0;                        // Outros coeficientes                        A_n_x = 0.0; A_s_x = 0.0; A_w_x = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoX = valorCondicaoFronteira( celula->east, ID_VAR_U, 'w' );                        // Momento y                        A_P_y = 1.0;                        A_e_y = 0.0;                        // Outros coeficientes                        A_n_y = 0.0; A_s_y = 0.0; A_w_y = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoY = valorCondicaoFronteira( celula->east, ID_VAR_V, 'w' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomento():" << endl                             << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no oeste!" << endl;                    }                }                // Volume ficticio (fronteira leste)                else if( celula->direcaoFronteira == FRONTEIRA_LESTE && celula->volumeFicticio == true )                {                    // Se no LESTE for saida de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_SAIDA_MASSA)                    {                        // Momento x                        A_P_x = 1.0;                        A_w_x = -1.0; //* (malha->M_oeste / malha->M_leste);                        // Outros coeficientes                        A_n_x = 0.0; A_s_x = 0.0; A_e_x = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoX = 0.0;                        //  Momento y                        A_P_y = 1.0;                        A_w_y = -1.0; //* (malha->M_oeste / malha->M_leste);                        // Outros coeficientes                        A_n_y = 0.0; A_s_y = 0.0; A_e_y = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoY = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomento():" << endl                             << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no leste!" << endl;                    }                }                // Volume ficticio (fronteira norte)                else if( celula->direcaoFronteira == FRONTEIRA_NORTE && celula->volumeFicticio == true )                {                    // Se o NORTE for fronteira impermeavel (u prescrito)                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Momento x                        A_P_x = 1.0;                        A_s_x = 1.0;                        // Outros coeficientes                        A_e_x = 0.0; A_w_x = 0.0; A_n_x = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoX = 2.0 * valorCondicaoFronteira( celula->south, ID_VAR_U, 'n' );                        // Momento y                        A_P_y = 1.0;                        A_s_y = 1.0;                        // Outros coeficientes                        A_e_y = 0.0; A_w_y = 0.0; A_n_y = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoY = 2.0 * valorCondicaoFronteira( celula->south, ID_VAR_V, 'n' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomento():" << endl                             << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no norte!" << endl;                    }                }                // Volume ficticio (fronteira sul)                else if( celula->direcaoFronteira == FRONTEIRA_SUL && celula->volumeFicticio )                {                    // Se o SUL for fronteira impermeavel (u prescrito)                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Momento x                        A_P_x = 1.0;                        A_n_x = 1.0;                        // Outros coeficientes                        A_e_x = 0.0; A_w_x = 0.0; A_s_x = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoX = 2.0 * valorCondicaoFronteira( celula->north, ID_VAR_U, 's' );                        // Momento y                        A_P_y = 1.0;                        A_n_y = 1.0;                        // Outros coeficientes                        A_e_y = 0.0; A_w_y = 0.0; A_s_y = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoY = 2.0 * valorCondicaoFronteira( celula->north, ID_VAR_V, 's' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomento():" << endl                             << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no sul!" << endl;                    }                }                // Volumes internos                else                {                    // Momento x                    // Calculo dos coeficientes A das interfaces                    A_e_x = (0.5 - celula->eastFaceGamma) * (celula->eastFaceRho)                          * (celula->eastFaceU) * celula->faceLength                          - (celula->eastFaceMi) * (celula->eastFaceBeta);                    A_w_x = -(0.5 + celula->westFaceGamma) * (celula->westFaceRho)                          * (celula->westFaceU) * celula->faceLength                          - (celula->westFaceMi) * (celula->westFaceBeta);                    A_n_x = (0.5 - celula->northFaceGamma) * (celula->northFaceRho)                          * (celula->northFaceV) * celula->faceLength                          - (celula->northFaceMi) * (celula->northFaceBeta);                    A_s_x = -(0.5 + celula->southFaceGamma) * (celula->southFaceRho)                          * (celula->southFaceV) * celula->faceLength                          - (celula->southFaceMi) * (celula->southFaceBeta);                    S_P_x = (-celula->eastFaceMi * celula->eastFaceBeta                             -celula->westFaceMi * celula->westFaceBeta) / 3.0;                    // Calculo do coeficiente A principal                    A_P_x = - A_e_x - A_w_x - A_n_x - A_s_x - S_P_x                          + (celula->rhoAnterior) * (celula->faceLength / malha->deltaT) * celula->faceLength;                    // Momento y                    // Calculo dos coeficientes A das interfaces                    A_e_y = (0.5 - celula->eastFaceGamma) * (celula->eastFaceRho)                          * (celula->eastFaceU) * celula->faceLength                          - (celula->eastFaceMi) * (celula->eastFaceBeta);                    A_w_y = -(0.5 + celula->westFaceGamma) * (celula->westFaceRho)                          * (celula->westFaceU) * celula->faceLength                          - (celula->westFaceMi) * (celula->westFaceBeta);                    A_n_y = (0.5 - celula->northFaceGamma) * (celula->northFaceRho)                          * (celula->northFaceV) * celula->faceLength                          - (celula->northFaceMi) * (celula->northFaceBeta);                    A_s_y = -(0.5 + celula->southFaceGamma) * (celula->southFaceRho)                          * (celula->southFaceV) * celula->faceLength                          - (celula->southFaceMi) * (celula->southFaceBeta);                    S_P_y = (-celula->northFaceMi * celula->northFaceBeta                             -celula->southFaceMi * celula->southFaceBeta) / 3.0;                    // Calculo do coeficiente A principal                    A_P_y = - A_e_y - A_w_y - A_n_y - A_s_y - S_P_y                          + (celula->rhoAnterior) * (celula->faceLength / malha->deltaT) * celula->faceLength;                }                // Insere coeficiente principal do momento x na lista encadeada                celula->iniciaElement( A_P_x, &(celula->firstElementMomentoX) );                // Insere coeficientes dos vizinhos na mesma lista encadeada                if(celula->direcaoFronteira != FRONTEIRA_NORTE)                    insereCoeficientesVizinho(celula, celula->north, A_n_x, ID_VAR_U);                if(celula->direcaoFronteira != FRONTEIRA_SUL)                    insereCoeficientesVizinho(celula, celula->south, A_s_x, ID_VAR_U);                if(celula->direcaoFronteira != FRONTEIRA_LESTE)                    insereCoeficientesVizinho(celula, celula->east,  A_e_x, ID_VAR_U);                if(celula->direcaoFronteira != FRONTEIRA_OESTE)                    insereCoeficientesVizinho(celula, celula->west,  A_w_x, ID_VAR_U);                //celula->insereElement( A_e_x, celula->east, &(celula->firstElementMomentoX) );                //celula->insereElement( A_w_x, celula->west, &(celula->firstElementMomentoX) );                //celula->insereElement( A_n_x, celula->north, &(celula->firstElementMomentoX) );                //celula->insereElement( A_s_x, celula->south, &(celula->firstElementMomentoX) );                // Insere coeficiente principal do momento y na lista encadeada                celula->iniciaElement( A_P_y, &(celula->firstElementMomentoY) );                // Insere coeficientes dos vizinhos na mesma lista encadeada                if(celula->direcaoFronteira != FRONTEIRA_NORTE)                    insereCoeficientesVizinho(celula, celula->north, A_n_y, ID_VAR_V);                if(celula->direcaoFronteira != FRONTEIRA_SUL)                    insereCoeficientesVizinho(celula, celula->south, A_s_y, ID_VAR_V);                if(celula->direcaoFronteira != FRONTEIRA_LESTE)                    insereCoeficientesVizinho(celula, celula->east,  A_e_y, ID_VAR_V);                if(celula->direcaoFronteira != FRONTEIRA_OESTE)                    insereCoeficientesVizinho(celula, celula->west,  A_w_y, ID_VAR_V);                //celula->insereElement( A_e_y, celula->east, &(celula->firstElementMomentoY) );                //celula->insereElement( A_w_y, celula->west, &(celula->firstElementMomentoY) );                //celula->insereElement( A_n_y, celula->north, &(celula->firstElementMomentoY) );                //celula->insereElement( A_s_y, celula->south, &(celula->firstElementMomentoY) );            }        }        //pausar(2);        return SUCESSO;    }    else    {        cout << "Na funcao calculaCoeficientesMomento():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaCoeficientesMomento():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaTermoFonteMomento()    Calcula o termo fonte dos momentos x e y para cada celula,adicionando na matriz [B] do sistema associado aos momento x e y.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 12/11/07.______________________________________________________________________________*/int calculaTermoFonteMomento( Grid *malha ){    Cell *celula;    // Termo fonte    double S_c = 0.0,           S_e = 0.0,           S_w = 0.0,           S_n = 0.0,           S_s = 0.0;    double uVizLeste = 0.0,           uVizOeste = 0.0,           vVizNorte = 0.0,           vVizSul = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if( !celula->volumeFicticio )            {                uVizLeste = calculaVarVizinho( celula->east, ID_VAR_U, celula->level );                uVizOeste = calculaVarVizinho( celula->west, ID_VAR_U, celula->level );                // Termo fonte do momento x                S_e = (celula->eastFaceMi) * (celula->eastFaceBeta) / 3.0;                S_w = (celula->westFaceMi) * (celula->westFaceBeta) / 3.0;                S_c = celula->faceLength *                      ( celula->northFaceMi * derivada('v', 'x', celula, 'n')                      - celula->southFaceMi * derivada('v', 'x', celula, 's') )                      + celula->faceLength * ( 2.0 / 3.0 )                      * ( - celula->eastFaceMi * derivada('v', 'y', celula, 'e')                          + celula->westFaceMi * derivada('v', 'y', celula, 'w') )                      - celula->faceLength * ( celula->eastFaceP - celula->westFaceP )                      + S_e * uVizLeste + S_w * uVizOeste;                // Insere o membro direito da equacao no vetor b                celula->b_MomentoX = S_c + ( celula->rhoAnterior * celula->faceLength                                   * celula->uAnterior ) * (celula->faceLength / malha->deltaT);                vVizNorte = calculaVarVizinho( celula->north, ID_VAR_V, celula->level );                vVizSul = calculaVarVizinho( celula->south, ID_VAR_V, celula->level );                // Termo fonte do momento y                S_n = (celula->northFaceMi) * (celula->northFaceBeta) / 3.0;                S_s = (celula->southFaceMi) * (celula->southFaceBeta) / 3.0;                S_c = celula->faceLength *                    ( celula->eastFaceMi * derivada('u', 'y', celula, 'e')                    - celula->westFaceMi * derivada('u', 'y', celula, 'w') )                    + celula->faceLength * ( 2.0 / 3.0 )                    * ( - celula->northFaceMi * derivada('u', 'x', celula, 'n')                        + celula->southFaceMi * derivada('u', 'x', celula,'s') )                    - celula->faceLength * ( celula->northFaceP - celula->southFaceP )                    + S_n * vVizNorte + S_s * vVizSul;                // Insere o membro direito da equacao no vetor b                celula->b_MomentoY = S_c + ( celula->rhoAnterior * celula->faceLength                            * celula->vAnterior ) * (celula->faceLength / malha->deltaT);            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaTermoFonteMomento():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaTermoFonteMomento():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaVelocidadesNasFaces()    Calcula o valor de u e v em todas as interfaces da malha, atraves da mediaponderada entre os valores de u nos centros das celulas correspondentes. O pesousado e' o coeficiente A_P da equacao do momento.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 25/04/07.Atualizado pro Andre Staltz dia 29/05/07.______________________________________________________________________________*//*int calculaVelocidadesNasFaces( Grid *malha ){    // Celula da malha    Cell *celula;    // A_P de uma celula e da sua vizinha    double A_P_u = 0.0,           A_P_v = 0.0,           A_P_viz = 0.0;    double somatorioUVizinhosP = 0.0,           somatorioUVizinhosE = 0.0,           somatorioUVizinhosW = 0.0,           somatorioVVizinhosP = 0.0,           somatorioVVizinhosN = 0.0,           somatorioVVizinhosS = 0.0;    double S_e__P = 0.0,           S_w__P = 0.0,           S_e__E = 0.0,           S_w__E = 0.0,           S_e__W = 0.0,           S_w__W = 0.0,           S_n__P = 0.0,           S_s__P = 0.0,           S_n__N = 0.0,           S_s__N = 0.0,           S_n__S = 0.0,           S_s__S = 0.0;    double uVizLesteP = 0.0,           uVizOesteP = 0.0,           uVizLesteE = 0.0,           uVizOesteW = 0.0,           vVizNorteP = 0.0,           vVizSulP   = 0.0,           vVizNorteN = 0.0,           vVizSulS   = 0.0,           pVizLesteP = 0.0,           pVizOesteP = 0.0,           pVizNorteP = 0.0,           pVizSulP   = 0.0;    double termoFontePu = 0.0,           termoFonteEu = 0.0,           termoFonteWu = 0.0,           termoFontePv = 0.0,           termoFonteNv = 0.0,           termoFonteSv = 0.0,           Massa_P = 0.0,           Massa_E = 0.0,           Massa_W = 0.0,           Massa_N = 0.0,           Massa_S = 0.0;    Element *elementAux;    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if( !celula->volumeFicticio && celula->active )            {                // Obtem o A_P^u e o A_P^v da celula atual ========================================                if( celula->firstElementMomentoX != NULL                ||  celula->firstElementMomentoY != NULL ) // Verifica erro                {                    A_P_u = celula->firstElementMomentoX->value;                    A_P_v = celula->firstElementMomentoY->value;                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula: " << celula->gridPosition << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem termos principais ========================================================                // Obtem somatorio dos u vizinhos de P com seus coeficientes                somatorioUVizinhosP = 0.0;                for(elementAux = celula->firstElementMomentoX->next;                    elementAux != NULL;                    elementAux = elementAux->next )                {                    somatorioUVizinhosP += elementAux->value * elementAux->cell->uAtual;                }                // Obtem somatorio dos v vizinhos de P com seus coeficientes                somatorioVVizinhosP = 0.0;                for(elementAux = celula->firstElementMomentoY->next;                    elementAux != NULL;                    elementAux = elementAux->next )                {                    somatorioVVizinhosP += elementAux->value * elementAux->cell->vAtual;                }                // Obtem termo fonte do momento x da celula central =================================                //obtemVariaveisVizinhas( celula, ID_VAR_U, NULL, NULL, &uVizLesteP, &uVizOesteP );                uVizLesteP = celula->east->uAtual;                uVizOesteP = celula->west->uAtual;                S_e__P = celula->eastFaceMi * celula->eastFaceBeta / 3.0;                S_w__P = celula->westFaceMi * celula->westFaceBeta / 3.0;                termoFontePu = celula->faceLength *                    ( celula->northFaceMi * derivada('v', 'x', celula, 'n')                    - celula->southFaceMi * derivada('v', 'x', celula, 's') )                    + celula->faceLength * ( 2.0 / 3.0 )                    * (- celula->eastFaceMi * derivada('v', 'y', celula, 'e')                       + celula->westFaceMi * derivada('v', 'y', celula, 'w') )                    + S_e__P * uVizLesteP + S_w__P * uVizOesteP;                // Obtem termo fonte do momento y da celula central =================================                //obtemVariaveisVizinhas( celula, ID_VAR_V, &vVizNorteP, &vVizSulP, NULL, NULL );                vVizNorteP = celula->north->vAtual;                vVizSulP = celula->south->vAtual;                S_n__P = celula->northFaceMi * celula->northFaceBeta / 3.0;                S_s__P = celula->southFaceMi * celula->southFaceBeta / 3.0;                termoFontePv = celula->faceLength *                    ( celula->eastFaceMi * derivada('u','y',celula, 'e')                    - celula->westFaceMi * derivada('u','y',celula, 'w') )                    + celula->faceLength * ( 2.0 / 3.0 ) *                    (- celula->northFaceMi * derivada('u','x',celula, 'n')                     + celula->southFaceMi * derivada('u','x',celula, 's') )                    + S_n__P * vVizNorteP + S_s__P * vVizSulP;                // Obtem a massa da celula central =============================================                Massa_P = celula->rhoAnterior * AO_QUADRADO( celula->faceLength );                // ##### Calcula velocidade u na face leste #########################################                if( celula->east->firstElementMomentoX != NULL )                {                    // Obtem o A_P_E                    A_P_viz = celula->east->firstElementMomentoX->value;                    // Obtem somatorio dos u vizinhos de E com seus coeficientes                    somatorioUVizinhosE = 0.0;                    for(elementAux = celula->east->firstElementMomentoX->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        somatorioUVizinhosE += elementAux->value * elementAux->cell->uAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massas M_P e M_E no tempo anterior                Massa_E = celula->east->rhoAnterior * AO_QUADRADO( celula->east->faceLength );                //obtemVariaveisVizinhas( celula, ID_VAR_P, NULL, NULL, &pVizLesteP, &pVizOesteP );                pVizLesteP = celula->east->pAtual;                pVizOesteP = celula->west->pAtual;                // Calcula u_e para essa celula                if(celula->east->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_e                    celula->I_e = - somatorioUVizinhosP - somatorioUVizinhosE                                  + termoFontePu                                  + ( (Massa_P + Massa_E) * celula->eastFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizLesteP - celula->pAtual );                    celula->eastFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'e' );                }                else                {                    // Obtem L[S]_E =================================                    //obtemVariaveisVizinhas( celula->east, ID_VAR_U, NULL, NULL, &uVizLesteE, NULL );                    uVizLesteE = celula->east->east->uAtual;                    S_e__E = (celula->east->eastFaceMi) * (celula->east->eastFaceBeta) / 3.0;                    S_w__E = (celula->east->westFaceMi) * (celula->east->westFaceBeta) / 3.0;                    termoFonteEu = celula->east->faceLength *                        ( celula->east->northFaceMi * derivada('v', 'x', celula->east, 'n')                        - celula->east->southFaceMi * derivada('v', 'x', celula->east, 's') )                        + celula->east->faceLength * ( 2.0 / 3.0 )                        * ( -celula->east->eastFaceMi * derivada('v', 'y', celula->east, 'e')                        + celula->east->westFaceMi * derivada('v', 'y', celula->east, 'w') )                        + S_e__E * uVizLesteE + S_w__E * celula->uAtual;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_e = - somatorioUVizinhosP - somatorioUVizinhosE                                  + termoFontePu + termoFonteEu                                  + ( (Massa_P + Massa_E) * celula->eastFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizLesteP - celula->pAtual );                    celula->eastFaceU = celula->I_e / ( A_P_u + A_P_viz );                }                // ##### Calcula velocidade u na face oeste #########################################                // Obtem somatorio dos u vizinhos de W com seus coeficientes                if( celula->west->firstElementMomentoX != NULL )                {                    // Obtem o A_P_W                    A_P_viz = celula->west->firstElementMomentoX->value;                    somatorioUVizinhosW = 0.0;                    for(elementAux = celula->west->firstElementMomentoX->next;                        elementAux != NULL;                        elementAux = elementAux->next)                    {                        somatorioUVizinhosW += elementAux->value * elementAux->cell->uAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massas M_W no tempo anterior                Massa_W = celula->west->rhoAnterior * AO_QUADRADO( celula->west->faceLength );                // Calcula u_w para essa celula                if(celula->west->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_w                    celula->I_w = - somatorioUVizinhosP - somatorioUVizinhosW                                  + termoFontePu                                  + ( (Massa_P + Massa_W) * celula->westFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( celula->pAtual - pVizOesteP );                    celula->westFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'w' );                }                else                {                    // Obtem L[S]_W =================================                    //obtemVariaveisVizinhas( celula->west, ID_VAR_U, NULL, NULL, NULL, &uVizOesteW );                    uVizOesteW = celula->west->west->uAtual;                    S_e__W = (celula->west->eastFaceMi) * (celula->west->eastFaceBeta) / 3.0;                    S_w__W = (celula->west->westFaceMi) * (celula->west->westFaceBeta) / 3.0;                    termoFonteWu = celula->west->faceLength *                        ( celula->west->northFaceMi * derivada('v', 'x', celula->west, 'n')                        - celula->west->southFaceMi * derivada('v', 'x', celula->west, 's') )                        + celula->west->faceLength * ( 2.0 / 3.0 )                        * ( - celula->west->eastFaceMi * derivada('v', 'y', celula->west, 'e')                            + celula->west->westFaceMi * derivada('v', 'y', celula->west, 'w') )                        + S_e__W * celula->uAtual + S_w__W * uVizOesteW;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_w = - somatorioUVizinhosP - somatorioUVizinhosW                                  + termoFontePu + termoFonteWu                                  + ( (Massa_P + Massa_W) * celula->westFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( celula->pAtual - pVizOesteP );                    celula->westFaceU = celula->I_w / ( A_P_u + A_P_viz );                }                // ##### Calcula velocidade v na face norte #########################################                if( celula->north->firstElementMomentoY != NULL )                {                    // Obtem o A_P_N                    A_P_viz = celula->north->firstElementMomentoY->value;                    // Obtem somatorio dos v vizinhos de N com seus coeficientes                    somatorioVVizinhosN = 0.0;                    for(elementAux = celula->north->firstElementMomentoY->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        somatorioVVizinhosN += elementAux->value * elementAux->cell->vAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massa M_N no tempo anterior                Massa_N = celula->north->rhoAnterior * AO_QUADRADO( celula->north->faceLength );                // Obtem o I_n pela formula 7.72 do livro do Maliska                //obtemVariaveisVizinhas( celula, ID_VAR_P, &pVizNorteP, &pVizSulP, NULL, NULL );                pVizNorteP = celula->north->pAtual;                pVizSulP = celula->south->pAtual;                // Calcula v_n para essa celula                if(celula->north->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_n                    // I_n e' necessario na correcao de pressao                    celula->I_n = - somatorioVVizinhosP - somatorioVVizinhosN                                  + termoFontePv                                  + ( (Massa_P + Massa_N) * celula->northFaceVAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizNorteP - celula->pAtual );                    celula->northFaceV = valorCondicaoFronteira( celula, ID_VAR_V, 'n' );                }                else                {                    // Obtem L[S]_N =================================                    //obtemVariaveisVizinhas( celula->north, ID_VAR_V, &vVizNorteN, NULL, NULL, NULL );                    vVizNorteN = celula->north->north->vAtual;                    S_n__N = (celula->north->northFaceMi) * (celula->north->northFaceBeta) / 3.0;                    S_s__N = (celula->north->southFaceMi) * (celula->north->southFaceBeta) / 3.0;                    termoFonteNv = celula->north->faceLength *                        ( celula->north->eastFaceMi * derivada('u', 'y', celula->north, 'e')                        - celula->north->westFaceMi * derivada('u', 'y', celula->north, 'w') )                        + celula->north->faceLength * ( 2.0 / 3.0 ) *                        ( - celula->north->northFaceMi * derivada('u', 'x', celula->north, 'n')                          + celula->north->southFaceMi * derivada('u', 'x', celula->north, 's') )                        + S_n__N * vVizNorteN + S_s__N * celula->vAtual;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_n = - somatorioVVizinhosP - somatorioVVizinhosN                                  + termoFontePv + termoFonteNv                                  + ( (Massa_P + Massa_N) * celula->northFaceVAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizNorteP - celula->pAtual );                    celula->northFaceV = celula->I_n / ( A_P_v + A_P_viz );                }                // ##### Calcula velocidade v na face sul #########################################                if( celula->south->firstElementMomentoY != NULL )                {                    // Obtem o A_P_S                    A_P_viz = celula->south->firstElementMomentoY->value;                    // Obtem somatorio dos v vizinhos de S com seus coeficientes                    somatorioVVizinhosS = 0.0;                    for(elementAux = celula->south->firstElementMomentoY->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        somatorioVVizinhosS += elementAux->value * elementAux->cell->vAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massa M_S no tempo anterior                Massa_S = celula->south->rhoAnterior * AO_QUADRADO( celula->south->faceLength );                // Calcula v_s para essa celula                if(celula->south->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_s                    celula->I_s = - somatorioVVizinhosP - somatorioVVizinhosS                                  + termoFontePv                                  + ( (Massa_P + Massa_S) * celula->southFaceVAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( celula->pAtual - pVizSulP );                    celula->southFaceV = valorCondicaoFronteira( celula, ID_VAR_V, 's' );                }                else                {                    // Obtem L[S]_N =================================                    //obtemVariaveisVizinhas( celula->south, ID_VAR_V, NULL, &vVizSulS, NULL, NULL );                    vVizSulS = celula->south->south->vAtual;                    S_n__S = (celula->south->northFaceMi) * (celula->south->northFaceBeta) / 3.0;                    S_s__S = (celula->south->southFaceMi) * (celula->south->southFaceBeta) / 3.0;                    termoFonteSv = celula->south->faceLength *                        ( celula->south->eastFaceMi * derivada('u', 'y', celula->south, 'e')                        - celula->south->westFaceMi * derivada('u', 'y', celula->south, 'w') )                        + celula->south->faceLength * ( 2.0 / 3.0 ) *                        ( - celula->south->northFaceMi * derivada('u', 'x', celula->south, 'n')                          + celula->south->southFaceMi * derivada('u', 'x', celula->south, 's') )                        + S_n__S * celula->vAtual + S_s__S * vVizSulS;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_s = - somatorioVVizinhosP - somatorioVVizinhosS                                + termoFontePv + termoFonteSv                                + ( (Massa_P + Massa_S) * celula->southFaceVAnterior ) / (malha->deltaT)                                - celula->faceLength * ( celula->pAtual - pVizSulP );                    celula->southFaceV = celula->I_s / ( A_P_v + A_P_viz );                }                // Outras interfaces ======================================================                celula->southFaceU = interpolaVariavelFace( celula, ID_VAR_U, 's' );                celula->northFaceU = interpolaVariavelFace( celula, ID_VAR_U, 'n' );                celula->eastFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'e' );                celula->westFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'w' );            }            // Calcula velocidades nas faces dos ficticios            else if( celula->volumeFicticio && celula->active )            {                // Velocidade u                celula->northFaceU = interpolaVariavelFace( celula, ID_VAR_U, 'n' );                celula->southFaceU = interpolaVariavelFace( celula, ID_VAR_U, 's' );                celula->eastFaceU  = interpolaVariavelFace( celula, ID_VAR_U, 'e' );                celula->westFaceU  = interpolaVariavelFace( celula, ID_VAR_U, 'w' );                // Velocidade v                celula->northFaceV = interpolaVariavelFace( celula, ID_VAR_V, 'n' );                celula->southFaceV = interpolaVariavelFace( celula, ID_VAR_V, 's' );                celula->eastFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'e' );                celula->westFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'w' );            }        }        return SUCESSO;    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;        return ERRO_MALHA_VAZIA;    }    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;    return ERRO_FLUXO_EXECUCAO;}*//*______________________________________________________________________________                   calculaVelocidadesNasFaces()    Calcula o valor de u e v em todas as interfaces da malha, atraves da mediaponderada entre os valores de u nos centros das celulas correspondentes. O pesousado e' o coeficiente A_P da equacao do momento.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 25/04/07.Atualizado pro Andre Staltz dia 29/05/07.______________________________________________________________________________*/int calculaVelocidadesNasFaces( Grid *malha ){    // Celula da malha    Cell *celula;    // A_P de uma celula e da sua vizinha    double A_P_u = 0.0,           A_P_v = 0.0,           A_P_viz = 0.0;    double somatorioUVizinhosP = 0.0,           somatorioUVizinhosE = 0.0,           somatorioUVizinhosW = 0.0,           somatorioVVizinhosP = 0.0,           somatorioVVizinhosN = 0.0,           somatorioVVizinhosS = 0.0;    double S_e__P = 0.0,           S_w__P = 0.0,           S_n__P = 0.0,           S_s__P = 0.0;    double uVizLesteP = 0.0,           uVizOesteP = 0.0,           vVizNorteP = 0.0,           vVizSulP   = 0.0,           pVizLesteP = 0.0,           pVizOesteP = 0.0,           pVizNorteP = 0.0,           pVizSulP   = 0.0;    double termoFontePu = 0.0,           termoFonteEu = 0.0,           termoFonteWu = 0.0,           termoFontePv = 0.0,           termoFonteNv = 0.0,           termoFonteSv = 0.0,           Massa_P = 0.0,           Massa_E = 0.0,           Massa_W = 0.0,           Massa_N = 0.0,           Massa_S = 0.0;    Element *elementAux;    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if( !celula->volumeFicticio && celula->active )            {                // Obtem o A_P^u e o A_P^v da celula atual ========================================                if( celula->firstElementMomentoX != NULL ||                    celula->firstElementMomentoY != NULL ) // Verifica erro                {                    A_P_u = celula->firstElementMomentoX->value;                    A_P_v = celula->firstElementMomentoY->value;                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula: " << celula->gridPosition << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem termos principais ========================================================                // Obtem somatorio dos u vizinhos de P com seus coeficientes                somatorioUVizinhosP = 0.0;                for(elementAux = celula->firstElementMomentoX->next;                    elementAux != NULL;                    elementAux = elementAux->next )                {                    somatorioUVizinhosP += elementAux->value * elementAux->cell->uAtual;                }                // Obtem somatorio dos v vizinhos de P com seus coeficientes                somatorioVVizinhosP = 0.0;                for(elementAux = celula->firstElementMomentoY->next;                    elementAux != NULL;                    elementAux = elementAux->next )                {                    somatorioVVizinhosP += elementAux->value * elementAux->cell->vAtual;                }                // Obtem termo fonte do momento x da celula central =================================                uVizLesteP = calculaVarVizinho( celula->east, ID_VAR_U, celula->level );                uVizOesteP = calculaVarVizinho( celula->west, ID_VAR_U, celula->level );                S_e__P = celula->eastFaceMi * celula->eastFaceBeta / 3.0;                S_w__P = celula->westFaceMi * celula->westFaceBeta / 3.0;                termoFontePu = celula->faceLength *                    ( celula->northFaceMi * derivada('v', 'x', celula, 'n')                    - celula->southFaceMi * derivada('v', 'x', celula, 's') )                    + celula->faceLength * ( 2.0 / 3.0 )                    * (- celula->eastFaceMi * derivada('v', 'y', celula, 'e')                       + celula->westFaceMi * derivada('v', 'y', celula, 'w') )                    + S_e__P * uVizLesteP + S_w__P * uVizOesteP;                // Obtem termo fonte do momento y da celula central =================================                vVizNorteP = calculaVarVizinho( celula->north, ID_VAR_V, celula->level );                vVizSulP = calculaVarVizinho( celula->south, ID_VAR_V, celula->level );                S_n__P = celula->northFaceMi * celula->northFaceBeta / 3.0;                S_s__P = celula->southFaceMi * celula->southFaceBeta / 3.0;                termoFontePv = celula->faceLength *                    ( celula->eastFaceMi * derivada('u', 'y', celula, 'e')                    - celula->westFaceMi * derivada('u', 'y', celula, 'w') )                    + celula->faceLength * ( 2.0 / 3.0 ) *                    (- celula->northFaceMi * derivada('u', 'x', celula, 'n')                     + celula->southFaceMi * derivada('u', 'x', celula, 's') )                    + S_n__P * vVizNorteP + S_s__P * vVizSulP;                // Obtem a massa da celula central =============================================                Massa_P = celula->rhoAnterior * AO_QUADRADO( celula->faceLength );                // ##### Calcula velocidade u na face leste #########################################                // Obtem o A_P_E                A_P_viz = calculaVarVizinho( celula->east, ID_VAR_A_P_X, celula->level );                // Obtem somatorio dos u vizinhos de E com seus coeficientes                somatorioUVizinhosE = calculaVarVizinho( celula->east, ID_VAR_SOMATORIO_U_VIZINHOS, celula->level );                // Obtem massas M_P e M_E no tempo anterior                Massa_E = calculaVarVizinho( celula->east, ID_VAR_MASSA_ANTERIOR, celula->level );                pVizLesteP = calculaVarVizinho( celula->east, ID_VAR_P, celula->level );                pVizOesteP = calculaVarVizinho( celula->west, ID_VAR_P, celula->level );                // Calcula u_e para essa celula                if( verificaVizFicticio( celula->east, celula->level ) )                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_e                    celula->I_e = - somatorioUVizinhosP - somatorioUVizinhosE                                  + termoFontePu                                  + ( (Massa_P + Massa_E) * celula->eastFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizLesteP - celula->pAtual );                    celula->eastFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'e' );                }                else                {                    // Obtem L[S]_E =================================                    termoFonteEu = calculaVarVizinho( celula->east, ID_VAR_TERMO_FONTE_U, celula->level );                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_e = - somatorioUVizinhosP - somatorioUVizinhosE                                  + termoFontePu + termoFonteEu                                  + ( (Massa_P + Massa_E) * celula->eastFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizLesteP - celula->pAtual );                    celula->eastFaceU = celula->I_e / ( A_P_u + A_P_viz );                }                // ##### Calcula velocidade u na face oeste #########################################                // Obtem o A_P_W                A_P_viz = calculaVarVizinho( celula->west, ID_VAR_A_P_X, celula->level );                // Obtem somatorio dos u vizinhos de W com seus coeficientes                somatorioUVizinhosW = calculaVarVizinho( celula->west, ID_VAR_SOMATORIO_U_VIZINHOS, celula->level );                // Obtem massas M_W no tempo anterior                Massa_W = calculaVarVizinho( celula->west, ID_VAR_MASSA_ANTERIOR, celula->level );                // Calcula u_w para essa celula                if( verificaVizFicticio( celula->west, celula->level ) )                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_w                    celula->I_w = - somatorioUVizinhosP - somatorioUVizinhosW                                  + termoFontePu                                  + ( (Massa_P + Massa_W) * celula->westFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( celula->pAtual - pVizOesteP );                    celula->westFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'w' );                }                else                {                    // Obtem L[S]_W =================================                    termoFonteWu = calculaVarVizinho( celula->west, ID_VAR_TERMO_FONTE_U, celula->level );                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_w = - somatorioUVizinhosP - somatorioUVizinhosW                                  + termoFontePu + termoFonteWu                                  + ( (Massa_P + Massa_W) * celula->westFaceUAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( celula->pAtual - pVizOesteP );                    celula->westFaceU = celula->I_w / ( A_P_u + A_P_viz );                }                // ##### Calcula velocidade v na face norte #########################################                // Obtem o A_P_N                A_P_viz = calculaVarVizinho( celula->north, ID_VAR_A_P_Y, celula->level );                // Obtem somatorio dos v vizinhos de N com seus coeficientes                somatorioVVizinhosN = calculaVarVizinho( celula->north, ID_VAR_SOMATORIO_V_VIZINHOS, celula->level );                // Obtem massa M_N no tempo anterior                Massa_N = calculaVarVizinho( celula->north, ID_VAR_MASSA_ANTERIOR, celula->level );                // Obtem o I_n pela formula 7.72 do livro do Maliska                pVizNorteP = calculaVarVizinho( celula->north, ID_VAR_P, celula->level );                pVizSulP = calculaVarVizinho( celula->south, ID_VAR_P, celula->level );                // Calcula v_n para essa celula                if( verificaVizFicticio( celula->north, celula->level ) )                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_n                    // I_n e' necessario na correcao de pressao                    celula->I_n = - somatorioVVizinhosP - somatorioVVizinhosN                                  + termoFontePv                                  + ( (Massa_P + Massa_N) * celula->northFaceVAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizNorteP - celula->pAtual );                    celula->northFaceV = valorCondicaoFronteira( celula, ID_VAR_V, 'n' );                }                else                {                    // Obtem L[S]_N =================================                    termoFonteNv = calculaVarVizinho( celula->north, ID_VAR_TERMO_FONTE_V, celula->level );                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_n = - somatorioVVizinhosP - somatorioVVizinhosN                                  + termoFontePv + termoFonteNv                                  + ( (Massa_P + Massa_N) * celula->northFaceVAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( pVizNorteP - celula->pAtual );                    celula->northFaceV = celula->I_n / ( A_P_v + A_P_viz );                }                // ##### Calcula velocidade v na face sul #########################################                // Obtem o A_P_S                A_P_viz = calculaVarVizinho( celula->south, ID_VAR_A_P_Y, celula->level );                // Obtem somatorio dos v vizinhos de S com seus coeficientes                somatorioVVizinhosS = calculaVarVizinho( celula->south, ID_VAR_SOMATORIO_V_VIZINHOS, celula->level );                // Obtem massa M_S no tempo anterior                Massa_S = calculaVarVizinho( celula->south, ID_VAR_MASSA_ANTERIOR, celula->level );                // Calcula v_s para essa celula                if( verificaVizFicticio( celula->south, celula->level ) )                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_s                    celula->I_s = - somatorioVVizinhosP - somatorioVVizinhosS                                  + termoFontePv                                  + ( (Massa_P + Massa_S) * celula->southFaceVAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( celula->pAtual - pVizSulP );                    celula->southFaceV = valorCondicaoFronteira( celula, ID_VAR_V, 's' );                }                else                {                    // Obtem L[S]_N =================================                    termoFonteSv = calculaVarVizinho( celula->south, ID_VAR_TERMO_FONTE_V, celula->level );                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_s = - somatorioVVizinhosP - somatorioVVizinhosS                                  + termoFontePv + termoFonteSv                                  + ( (Massa_P + Massa_S) * celula->southFaceVAnterior ) / (malha->deltaT)                                  - celula->faceLength * ( celula->pAtual - pVizSulP );                    celula->southFaceV = celula->I_s / ( A_P_v + A_P_viz );                }                // Outras interfaces ======================================================                celula->southFaceU = interpolaVariavelFace( celula, ID_VAR_U, 's' );                celula->northFaceU = interpolaVariavelFace( celula, ID_VAR_U, 'n' );                celula->eastFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'e' );                celula->westFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'w' );            }            // Calcula velocidades nas faces dos ficticios            else if( celula->volumeFicticio && celula->active )            {                // Velocidade u                celula->northFaceU = interpolaVariavelFace( celula, ID_VAR_U, 'n' );                celula->southFaceU = interpolaVariavelFace( celula, ID_VAR_U, 's' );                celula->eastFaceU  = interpolaVariavelFace( celula, ID_VAR_U, 'e' );                celula->westFaceU  = interpolaVariavelFace( celula, ID_VAR_U, 'w' );                // Velocidade v                celula->northFaceV = interpolaVariavelFace( celula, ID_VAR_V, 'n' );                celula->southFaceV = interpolaVariavelFace( celula, ID_VAR_V, 's' );                celula->eastFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'e' );                celula->westFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'w' );            }        }        return SUCESSO;    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;        return ERRO_MALHA_VAZIA;    }    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  convergenciaVelocidades()   Verifica a convergencia das velovidades.   Parametros:       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 25/04/07.Atualizado por Henrique dia 09/09/07.______________________________________________________________________________*/int convergenciaVelocidades( Grid *malha ){    Cell *celula; // Celula da malha    double deltaU = 0.0,           maiorDeltaU = 0.0,           maiorU = 0.0,           menorU = 0.0,           erroVelocidadeU = 0.0,           deltaV = 0.0,           maiorDeltaV = 0.0,           maiorV = 0.0,           menorV = 0.0,           erroVelocidadeV = 0.0;    if(malha->firstGridCell != NULL)    {        // Calcula os erros na pressao de todas as celulas ativas        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if( !celula->volumeFicticio && celula->active )            {                deltaU = fabs(celula->uAtual - celula->uIterAnterior);                if(deltaU > maiorDeltaU)                    maiorDeltaU = deltaU;                if(celula->uAtual > maiorU)                    maiorU = celula->uAtual;                if(celula->uAtual < menorU)                    menorU = celula->uAtual;                deltaV = fabs(celula->vAtual - celula->vIterAnterior);                if(deltaV > maiorDeltaV)                    maiorDeltaV = deltaV;                if(celula->vAtual > maiorV)                    maiorV = celula->vAtual;                if(celula->vAtual < menorV)                    menorV = celula->vAtual;            }        }        // Calcula o erro nas velocidades        if((maiorU - menorU) != 0.0)            erroVelocidadeU  = maiorDeltaU / (maiorU - menorU);        else            erroVelocidadeU = maiorDeltaU;        if((maiorV - menorV) != 0.0)            erroVelocidadeV  = maiorDeltaV / (maiorV - menorV);        else            erroVelocidadeV = maiorDeltaV;        // Verifica convergencia e retorna resultado        if ( erroVelocidadeU < COTA_VELOCIDADE_U && erroVelocidadeV < COTA_VELOCIDADE_V )            return SUCESSO;        else            return INSUCESSO;    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em convergenciaVelocidades()" << endl;        return ERRO_MALHA_VAZIA;    }}