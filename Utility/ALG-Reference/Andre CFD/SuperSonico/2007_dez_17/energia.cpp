/*  ========== energia.cpp =========    Contem funcoes para resolver a equacao da energia    de Navier-Stokes*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                   calculaCoeficientesEnergia()    Calcula os coeficientes F_p, F_e, F_w, F_n, F_s para cada celula da malhae constroi a matriz da energia. Calcula tambem o termo fonte B da equacao daenergia para cada celula e constroi o vetor b da energia.    Parametro:        malha: apontador para a malha em questao;Criado por Henrique dia 14/05/07.Atualizado por Henrique dia 12/06/07.______________________________________________________________________________*/int calculaCoeficientesEnergia( Grid *malha ){    Cell *celula;    short tipoFronteira;    // Coeficientes    double F_P = 0.0,           F_e = 0.0,           F_w = 0.0,           F_n = 0.0,           F_s = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Evitar caso especial dos quatro cantos ficticios: nao entram no sistema            if( celula->active )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_T );                // Volume ficticio (fronteira oeste)                if( celula->direcaoFronteira == FRONTEIRA_OESTE && celula->volumeFicticio == true )                {                    // Se no OESTE for entrada de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_ENTRADA_MASSA)                    {                        // Entrada de massa, coeficientes importantes                        F_P = 1.0;                        F_e = 0.0;                        // Outros coeficientes                        F_n = 0.0; F_s = 0.0; F_w = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_Energia = valorCondicaoFronteira( celula->east, ID_VAR_T, 'w' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesEnergia:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no oeste!" << endl;                    }                }                // Volume ficticio (fronteira leste)                else if( celula->direcaoFronteira == FRONTEIRA_LESTE && celula->volumeFicticio == true )                {                    // Se no LESTE for saida de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_SAIDA_MASSA)                    {                        // Saida de massa, coeficientes importantes                        F_P = 1.0;                        F_w = -1.0;                        // Outros coeficientes                        F_n = 0.0; F_s = 0.0; F_e = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_Energia = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesEnergia:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no leste!" << endl;                    }                }                // Volume ficticio (fronteira norte)                else if( celula->direcaoFronteira == FRONTEIRA_NORTE && celula->volumeFicticio == true )                {                    // Se no NORTE for prescrito                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Fronteira impermeavel, coeficientes importantes                        F_P = 1.0;                        F_s = 1.0;                        // Outros coeficientes                        F_e = 0.0; F_w = 0.0; F_n = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_Energia = 2.0 * valorCondicaoFronteira( celula->south, ID_VAR_T, 'n' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesEnergia:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no norte!" << endl;                    }                }                // Volume ficticio (fronteira sul)                else if( celula->direcaoFronteira == FRONTEIRA_SUL && celula->volumeFicticio == true )                {                    // Se no SUL for prescrito                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Fronteira impermeavel, coeficientes importantes                        F_P = 1.0;                        F_n = 1.0;                        // Outros coeficientes                        F_e = 0.0; F_w = 0.0; F_s = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_Energia = 2.0 * valorCondicaoFronteira( celula->north, ID_VAR_T, 's' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesEnergia:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no sul!" << endl;                    }                }                // Volumes internos                else                {                    double dudx = (celula->eastFaceU - celula->westFaceU) / celula->faceLength;                    double dvdy = (celula->northFaceV - celula->southFaceV) / celula->faceLength;                    double dudy = (celula->northFaceU - celula->southFaceU) / celula->faceLength;                    double dvdx = (celula->eastFaceV - celula->westFaceV) / celula->faceLength;                    celula->PhiAtual = (-2.0/3.0) * AO_QUADRADO(dudx + dvdy)                                    + 2.0 * (AO_QUADRADO(dudx) + AO_QUADRADO(dvdy))                                   + AO_QUADRADO(dudy + dvdx);                     // Calculo dos coeficientes da equacao da energia                    F_P = celula->rhoAtual * AO_QUADRADO(celula->faceLength) / malha->deltaT +                          celula->faceLength * (                              celula->eastFaceRho * celula->eastFaceU * ( 0.5 + celula->eastFaceGamma)                             - celula->westFaceRho * celula->westFaceU * (0.5 - celula->westFaceGamma)                             + celula->northFaceRho * celula->northFaceV * ( 0.5 + celula->northFaceGamma)                             - celula->southFaceRho * celula->southFaceV * (0.5 - celula->southFaceGamma)                          )                           + (1.0 / C_P) * (                              celula->eastFaceK * celula->eastFaceBeta                             + celula->westFaceK * celula->westFaceBeta                             + celula->northFaceK * celula->northFaceBeta                             + celula->southFaceK * celula->southFaceBeta );                    F_e = celula->eastFaceRho * celula->eastFaceU                         * ( 0.5 - celula->eastFaceGamma ) * celula->faceLength                         - (1.0 / C_P) * celula->eastFaceK * celula->eastFaceBeta;                    F_w = -celula->westFaceRho * celula->westFaceU                         * ( 0.5 + celula->westFaceGamma ) * celula->faceLength                         - (1.0 / C_P) * celula->westFaceK * celula->westFaceBeta;                    F_n = celula->northFaceRho * celula->northFaceV                         * (0.5 - celula->northFaceGamma) * celula->faceLength                        - (1.0 / C_P) * ( celula->northFaceK                                         * celula->northFaceBeta );                    F_s = - celula->southFaceRho * celula->southFaceV                         * (0.5 + celula->southFaceGamma) * celula->faceLength                        - (1.0 / C_P) * ( celula->southFaceK                                         * celula->southFaceBeta );                    // Calculo das pressoes nas interfaces da celula                    celula->northFaceP = interpolaVariavelFace( celula, ID_VAR_P, 'n' );                    celula->southFaceP = interpolaVariavelFace( celula, ID_VAR_P, 's' );                    celula->eastFaceP  = interpolaVariavelFace( celula, ID_VAR_P, 'e' );                    celula->westFaceP  = interpolaVariavelFace( celula, ID_VAR_P, 'w' );                    // Calcula o termo fonte da equacao da energia                    celula->b_Energia = celula->rhoAnterior * celula->TAnterior                        * AO_QUADRADO(celula->faceLength) / malha->deltaT                        + (1.0 / C_P) * (                             + celula->pAtual * AO_QUADRADO(celula->faceLength) / malha->deltaT                             - celula->pAnterior * AO_QUADRADO(celula->faceLength) / malha->deltaT                             + celula->faceLength * (                                  celula->uAtual * celula->eastFaceP                                  - celula->uAtual * celula->westFaceP                                  + celula->vAtual * celula->northFaceP                                  - celula->vAtual * celula->southFaceP                             )                             + (AO_QUADRADO(celula->faceLength) / 2.0) *                               ( celula->miAtual * celula->PhiAtual                                 -celula->miAnterior * celula->PhiAnterior)                        );                }                // Insere coeficiente F_P na lista encadeada                celula->iniciaElement( F_P, &(celula->firstElementEnergia) );                // Insere coeficientes dos vizinhos na mesma lista encadeada                if(celula->direcaoFronteira != FRONTEIRA_NORTE)                    insereCoeficientesVizinho(celula, celula->north, F_n, ID_VAR_T);                if(celula->direcaoFronteira != FRONTEIRA_SUL)                    insereCoeficientesVizinho(celula, celula->south, F_s, ID_VAR_T);                if(celula->direcaoFronteira != FRONTEIRA_LESTE)                    insereCoeficientesVizinho(celula, celula->east,  F_e, ID_VAR_T);                if(celula->direcaoFronteira != FRONTEIRA_OESTE)                    insereCoeficientesVizinho(celula, celula->west,  F_w, ID_VAR_T);            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaCoeficientesEnergia():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaCoeficientesEnergia():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  atualizaOutrosEscalares()   Atualiza os campos de temperatura, densidade, condutividade, viscosidade ao final de uma iteracao da equacao da energia.       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 14/05/07.Atualizado por Henrique dia 12/06/07.______________________________________________________________________________*/int atualizaOutrosEscalares( Grid *malha, double relaxamentoT ){    Cell *celula;    double energiaInterna = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        for( celula = malha->firstGridCell;             celula != NULL;             celula = celula->next)        {            if( celula->active )            {                // calcula temperatura                celula->TAtual =  relaxamentoT * celula->TAtual                               + (1.0 - relaxamentoT) * celula->TIterAnterior;                // calcula densidade                celula->rhoAtual = celula->pAtual / ( R * celula->TAtual );                // Calcula viscosidade                celula->miAtual = MI_ZERO                                * pow( celula->TAtual / TEMPERATURA_LIVRE, 3.0/2.0 )                                * (                                    (TEMPERATURA_LIVRE + 110.0)                                    /(celula->TAtual + 110.0)                                );                // Calcula condutividade termica                celula->kAtual = (celula->miAtual * GAMMA * (R / (GAMMA-1.0)) ) / PRANDTL;            }        }        return SUCESSO;    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em atualizaOutrosEscalares()" << endl;        return ERRO_MALHA_VAZIA;     }    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    cout << "Erro acima ocorreu em atualizaOutrosEscalares()" << endl;    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  convergenciaTemperatura()   Verifica a convergencia das temperaturas.   Parametros:       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 14/05/07.Atualizado por Henrique dia 09/07/09.______________________________________________________________________________*/int convergenciaTemperatura( Grid *malha ){    Cell *celula; // Celula da malha    double deltaT = 0.0,           maiorDeltaT = 0.0,           maiorT = 0.0,           menorT = 1000.0 * TEMPERATURA_LIVRE,           erroTemperatura = 0.0;    if(malha->firstGridCell != NULL)    {        // Calcula os erros na pressao de todas as celulas ativas        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if(celula->volumeFicticio == false && celula->active == true)            {                deltaT = fabs(celula->TAtual - celula->TIterAnterior);                if(deltaT > maiorDeltaT)                    maiorDeltaT = deltaT;                if(celula->TAtual > maiorT)                    maiorT = celula->TAtual;                if(celula->TAtual < menorT)                    menorT = celula->TAtual;            }        }        // Calcula o erro na tmeperatura        if((maiorT - menorT) != 0.0)            erroTemperatura = maiorDeltaT / (maiorT - menorT);        else        {            erroTemperatura = maiorDeltaT;        }        // Verifica convergencia e retorna resultado        if ( erroTemperatura < COTA_TEMPERATURA )            return SUCESSO;        else{            cout << "erroTemperatura = " << erroTemperatura << endl;            return INSUCESSO;        }    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em convergenciaTemperatura()" << endl;        return ERRO_MALHA_VAZIA;    }}