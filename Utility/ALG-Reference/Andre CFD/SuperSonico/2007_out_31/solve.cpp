/*  ========== solve.cpp =========    Contem funcoes para resolver as equacoes    de Navier-Stokes*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                              solveSuperSonicSIMPLEC()           Resolver por SIMPLEC (acoplamento pressao-velocidade/densidade)    o escoamento supersonico.Criado por Andre STALTZ dia 31/03/07______________________________________________________________________________*/void solveSuperSonicSIMPLEC( Grid *malha ){    bool convergiu = false;    int  iteracoesC = 0,         iteracoesB = 0,         iteracoesA = 0;    do // Ciclo A -------------------------------------------------------------    {        atualizaParametrosDaIteracaoAnterior( malha, 'A' );        interpolaTodasInterfaces( malha, 'A', false );        iteracoesB = 0;        do // Ciclo B -------------------------------------------------------------        {            atualizaParametrosDaIteracaoAnterior( malha, 'B' );            interpolaTodasInterfaces( malha, 'B', false );            atualiza_Gamma( malha );            atualiza_Beta( malha );            // Calcula entrada e saida de massa para satisfazer conservacao            //calculaFluxosMassa( malha );            // Item 2. (calcular os coeficientes do momentum de u* e v*)            calculaCoeficientesMomentoX( malha );            calculaCoeficientesMomentoY( malha );            iteracoesC = 0;            do // Ciclo C ---------------------------------------------------------            {                atualizaParametrosDaIteracaoAnterior( malha, 'C' );                calculaTermoFonteMomentoX( malha );                calculaTermoFonteMomentoY( malha );                // Item 3.                calculaCoeficientesCorrecaoPressao( malha );                // Item 4. (campo de velocidades u* e v* e' determinado)                cout << "Resolvendo matriz do momento-x...\t";                gradienteBiconjugadoEstabilizado( malha, ID_VAR_U );                cout << "Resolvendo matriz do momento-y...\t";                gradienteBiconjugadoEstabilizado( malha, ID_VAR_V );                calculaVelocidadesNasFaces( malha );                // Item 5. Termo fonte (b^P')                calculaTermoFonteCorrecaoPressao( malha );                // Item 6a. Resolver a equacao para P'                cout << "Resolvendo matriz de pressao'...\t";                gradienteBiconjugadoEstabilizado( malha, ID_VAR_PLINHA );                // Item 6b e 6c. Corrigir u*, v*, rho* e P*                        corrige_Velocidades_Densidades_Pressoes( malha, RELAXAMENTO_P,                                                         RELAXAMENTO_U, RELAXAMENTO_V );                // Verifica convergencia                if( convergenciaPressao( malha ) == SUCESSO )                    convergiu = true;                else                    convergiu = false;                iteracoesC++;                cout << endl;            // Item 7. Retorna ao item 3 ate' convergir ---------------------------            } while( !convergiu && iteracoesC < MAXITER_C ); // Ciclo C            cout << "\nIteracoes do ciclo C (Cor. Pressao): " << iteracoesC << endl;            // Verifica convergencia            if( convergenciaVelocidades( malha ) == SUCESSO )                convergiu = true;            else                convergiu = false;            iteracoesB++;        // Item 8. Retorna ao item 2 ate' convergir -------------------------------        } while( !convergiu && iteracoesB < MAXITER_B ); // Ciclo B        cout << "\nIteracoes do ciclo B (Velocidades): " << iteracoesB << endl;        // Item 9.        // Calcular os coeficientes da equacao de energia        calculaCoeficientesEnergia( malha );        // Resolve a equacao de energia total        cout << "Resolvendo matriz da energia total...\t";        gradienteBiconjugadoEstabilizado( malha, ID_VAR_T );        //imprimeMatriz( malha, ID_VAR_T );        // Campos de T, rho, mi, k sao determinados        atualizaOutrosEscalares( malha, RELAXAMENTO_T );        // Verifica convergencia da temperatura        if( convergenciaTemperatura( malha ) == SUCESSO )            convergiu = true;        else            convergiu = false;        iteracoesA++;    // Item 11. Retorna ao item 2 ate' convergir    } while( !convergiu && iteracoesA < MAXITER_A ); // Ciclo A    cout << "\nIteracoes do ciclo A (Temperatura): " << iteracoesA << endl;    // A solucao do problema em t + deltaT foi obtida!    cout << " Tempo atual: " << malha->tempoAtual << " s ################################" << endl;}/*______________________________________________________________________________                              condicaoInicial()           Configura as variaveis na condicao inicial, ou seja, em t = 0.______________________________________________________________________________*/int condicaoInicial( Grid *malha ){    Cell *celula;    // Ajusta tempo para zero    malha->tempoAtual = 0.0;        malha->cortarMalha(0.5);    definirCelulasFronteira( malha );    if(malha->firstGridCell != NULL)    {        // Ajustar todas as celulas com a configuracao inicial        for(celula = malha->firstGridCell;            celula != 0;             celula = celula->next)        {            if( celula->active )            {                // Variaveis de fluido                celula->pAtual = PRESSAO_LIVRE;                celula->pAnterior = celula->pAtual;                if(celula->volumeFicticio && celula->direcaoFronteira == FRONTEIRA_SUL)                {                    celula->uAtual = -VEL_LIVRE;                    celula->uAnterior = -VEL_LIVRE;                }                else                {                    celula->uAtual = VEL_LIVRE;                     celula->uAnterior = VEL_LIVRE;                 }                celula->vAtual = 0.0;                 celula->vAnterior = celula->vAtual;                 celula->TAtual = TEMPERATURA_LIVRE;                celula->TAnterior = TEMPERATURA_LIVRE;                celula->rhoAtual = PRESSAO_LIVRE / (R*celula->TAtual);                celula->rhoAnterior = PRESSAO_LIVRE / (R*celula->TAtual);                celula->miAtual = MI_ZERO;                celula->miAnterior = celula->miAtual;                celula->kAtual = (MI_ZERO * GAMMA * R) / ((GAMMA - 1.0) * PRANDTL);                celula->kAnterior = celula->kAtual;            }        }        interpolaTodasInterfaces( malha, 'A', true );        return SUCESSO;    }    else    {        cout << "Na funcao condicaoInicial():\n";        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao condicaoInicial():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*____________________________________________________________________________________                        calculaFluxosMassa()    Calcula a os fluxos de massa totais da malha, com base no valor de rho*V nas fronteiras do dominio.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 11/06/07._____________________________________________________________________________________*/int calculaFluxosMassa( Grid *malha ){    // ###########################################    // OBS! So' funciona para uma malha uniforme    // ###########################################'    Cell *celula;    //int bla;    malha->M_norte = malha->M_sul = malha->M_leste = malha->M_oeste = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Percorre as celulas que sao volumes ficticios da fronteira leste do dominio        // para calcular fluxo de massa        for(celula = malha->firstGridCell->south->west;            celula->volumeFicticio == false;            celula = celula->south)        {            malha->M_leste += celula->eastFaceRho * celula->eastFaceU;        }        // Percorre as celulas que sao volumes ficticios da fronteira sul do dominio        // para calcular fluxo de massa        for(celula = celula->north;             celula->volumeFicticio == false;            celula = celula->west)        {            malha->M_sul += celula->southFaceRho * celula->southFaceV;        }        // Percorre as celulas que sao volumes ficticios da fronteira oeste do dominio        // para calcular fluxo de massa        for(celula = celula->east;             celula->volumeFicticio == false;            celula = celula->north)        {            malha->M_oeste += celula->westFaceRho * celula->westFaceU;        }        // Percorre as celulas que sao volumes ficticios da fronteira norte do dominio        // para calcular fluxo de massa        for(celula = celula->south;             celula->volumeFicticio == false;            celula = celula->east)        {            malha->M_norte += celula->northFaceRho * celula->northFaceV;        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaFluxosMassa():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaFluxosMassa():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                              obtemVariaveisVizinhas()    Obtem (por parametro) os valores de uma certa variavel nas celulas vizinhasa celula atual. Essa funcao assume uma malha UNIFORME, mas consideratambem condicoes de fronteira. Retorna codigo de erro ou sucesso.    Parametros:         celula: a celula centrada em torno dos vizinhos         id_variavel: um identificador para saber qual variavel esta sendo                      solicitada;         varNorte: apontador para a variavel da celula do Norte (vai receber o resultado);         varSul: apontador para a variavel da celula do Sul (vai receber o resultado);         varLeste: apontador para a variavel da celula do Leste (vai receber o resultado);         varOeste: apontador para a variavel da celula do Oeste (vai receber o resultado);Criado por Andre STALTZ dia 31/03/07Atualizado por Henrique dia 24/04/07______________________________________________________________________________*/int obtemVariaveisVizinhas( Cell *celula, short id_variavel,                            double *varNorte, double *varSul,                            double *varLeste, double *varOeste ){    // Celulas vizinhas pretas ou de fronteira (supondo uma malha uniforme)    Cell *vizLeste,         *vizOeste,         *vizNorte,         *vizSul;    // Verifica erro de celula inexistente    if( celula == NULL )    {        IMPRIMIR_ERRO_CELULA_INEXISTENTE();        cout << "Erro acima ocorreu em obtemVariaveisVizinhas()" << endl;        return ERRO_CELULA_INEXISTENTE;    }    // Verifica erro de ID inexistente    if( id_variavel != ID_VAR_RHO    &&  id_variavel != ID_VAR_U    &&  id_variavel != ID_VAR_V    &&  id_variavel != ID_VAR_P    &&  id_variavel != ID_VAR_T    &&  id_variavel != ID_VAR_K    &&  id_variavel != ID_VAR_MI )    {        IMPRIMIR_ERRO_ID_VARIAVEL_INEXISTENTE();        cout << "Erro acima ocorreu em obtemVariaveisVizinhas()" << endl;        return ERRO_ID_VAR_INEXISTENTE;    }    // Determinar celulas vizinhas pretas ------------------------------    vizLeste = celula->east;    // Buscar no' preto ou no' de fronteira    while( ( vizLeste->type == 'w' ) &&           ( vizLeste->singleConnector != 0 )         )    {        vizLeste = vizLeste->singleConnector;    }    vizOeste = celula->west;    // Buscar no' preto ou no' de fronteira    while( ( vizOeste->type == 'w' ) &&           ( vizOeste->singleConnector != 0 )         )    {        vizOeste = vizOeste->singleConnector;    }    vizNorte = celula->north;    // Buscar no' preto ou no' de fronteira    while( ( vizNorte->type == 'w' ) &&           ( vizNorte->singleConnector != 0 )         )    {        vizNorte = vizNorte->singleConnector;    }    vizSul = celula->south;    // Buscar no' preto ou no' de fronteira    while( ( vizSul->type == 'w' ) &&           ( vizSul->singleConnector != 0 )         )    {        vizSul = vizSul->singleConnector;    }    if( varLeste != NULL )    {        // Retorna a variavel no vizinho leste        switch( id_variavel )        {            case ID_VAR_RHO:                *varLeste = vizLeste->rhoAtual;            break;            case ID_VAR_U:                *varLeste = vizLeste->uAtual;            break;            case ID_VAR_V:                *varLeste = vizLeste->vAtual;            break;            case ID_VAR_T:                *varLeste = vizLeste->TAtual;            break;            case ID_VAR_P:                *varLeste = vizLeste->pAtual;            break;            default:        // se nao e' nenhuma dessas variaveis, imprime um erro                IMPRIMIR_ERRO_VAR_NAO_IMPLEMENTADA();                cout << "Erro acima ocorreu em obtemVariaveisVizinhas()" << endl;            break;        }    }    if( varOeste != NULL )    {        // Retorna a variavel no vizinho oeste        switch( id_variavel )        {            case ID_VAR_RHO:                *varOeste = vizOeste->rhoAtual;            break;            case ID_VAR_U:                *varOeste = vizOeste->uAtual;            break;            case ID_VAR_V:                *varOeste = vizOeste->vAtual;            break;            case ID_VAR_T:                *varOeste = vizOeste->TAtual;            break;            case ID_VAR_P:                *varOeste = vizOeste->pAtual;            break;            default:        // se nao e' nenhuma dessas variaveis, imprime um erro                IMPRIMIR_ERRO_VAR_NAO_IMPLEMENTADA();                cout << "Erro acima ocorreu em obtemVariaveisVizinhas()" << endl;            break;        }    }    if( varNorte != NULL )    {        // Retorna a variavel no vizinho norte        switch( id_variavel )        {            case ID_VAR_RHO:                *varNorte = vizNorte->rhoAtual;            break;            case ID_VAR_U:                *varNorte = vizNorte->uAtual;            break;            case ID_VAR_V:                *varNorte = vizNorte->vAtual;            break;            case ID_VAR_T:                *varNorte = vizNorte->TAtual;            break;            case ID_VAR_P:                *varNorte = vizNorte->pAtual;            break;            default:        // se nao e' nenhuma dessas variaveis, imprime um erro                IMPRIMIR_ERRO_VAR_NAO_IMPLEMENTADA();                cout << "Erro acima ocorreu em obtemVariaveisVizinhas()" << endl;            break;        }    }    if( varSul != NULL )    {        // Retorna a variavel no vizinho sul        switch( id_variavel )        {            case ID_VAR_RHO:                *varSul = vizSul->rhoAtual;            break;            case ID_VAR_U:                *varSul = vizSul->uAtual;            break;            case ID_VAR_V:                *varSul = vizSul->vAtual;            break;            case ID_VAR_T:                *varSul = vizSul->TAtual;            break;            case ID_VAR_P:                *varSul = vizSul->pAtual;            break;            default:        // se nao e' nenhuma dessas variaveis, imprime um erro                IMPRIMIR_ERRO_VAR_NAO_IMPLEMENTADA();                cout << "Erro acima ocorreu em obtemVariaveisVizinhas()" << endl;            break;        }    }    return SUCESSO;}/*______________________________________________________________________________                  atualizaParametrosDaIteracaoAnterior()   Atualiza parametros no inicio de cada iteracaopara a verificacao do criterio   de convergencia ao final da mesma.   Parametros:       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 25/04/07.Atualizado por Henrique dia 12/06/07.______________________________________________________________________________*/int atualizaParametrosDaIteracaoAnterior( Grid *malha, char ciclo ){    Cell *celula;    if( ciclo != 'A'    &&  ciclo != 'B'    &&  ciclo != 'C' )    {        cout << "Erro ciclo inexistente\n";        return INSUCESSO;    }    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for( celula = malha->firstGridCell;             celula != NULL;             celula = celula->next)        {            if( celula->active )            {                // atualiza parametros                if( ciclo == 'A' )                {                    celula->TIterAnterior = celula->TAtual;                }                else if( ciclo == 'B' )                {                    celula->uIterAnterior = celula->uAtual;                    celula->vIterAnterior = celula->vAtual;                }                else if( ciclo == 'C' )                {                    celula->pIterAnterior = celula->pAtual;                }            }        }        return SUCESSO;    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em atualizaParametrosDaIteracaoAnterior()" << endl;        return ERRO_MALHA_VAZIA;    }    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    cout << "Erro acima ocorreu em atualizaParametrosDaIteracaoAnterior()" << endl;    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  atualizaParametrosDoTempoAnterior()   Atualiza parametros para prosseguir em um proximo passo de tempo.   Parametros:       malha: apontador para a malha em questao;Criado por Andre STALTZ dia 08/05/07______________________________________________________________________________*/int atualizaParametrosDoTempoAnterior( Grid *malha ){    Cell *celula;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for( celula = malha->firstGridCell;             celula != NULL;             celula = celula->next)        {            if( celula->active )            {                // Atualiza parametros                celula->uAnterior = celula->uAtual;                celula->eastFaceUAnterior = celula->eastFaceU;                celula->westFaceUAnterior = celula->westFaceU;                celula->vAnterior = celula->vAtual;                celula->northFaceVAnterior = celula->northFaceV;                celula->southFaceVAnterior = celula->southFaceV;                celula->pAnterior = celula->pAtual;                celula->rhoAnterior = celula->rhoAtual;                celula->TAnterior = celula->TAtual;                celula->PhiAnterior = celula->PhiAtual;            }        }        return SUCESSO;    }    else    {        cout << "Na funcao atualizaParametrosDoTempoAnterior():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao atualizaParametrosDoTempoAnterior():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                        calculaResiduos()    Calcula os residuos das variaveis importantes para desenhar seus graficos.Residuo de uma equacao = || A x - b ||_2______________________________________________________________________________*/void calculaResiduos( Grid *malha, int iteracaoAtual ){    Cell *celula; // Celula da malha    double residuoU = 0.0,           residuoUdaCelula = 0.0,           residuoV = 0.0,           residuoVdaCelula = 0.0,           residuoMassa = 0.0,           residuoP = 0.0,           residuoPdaCelula = 0.0,           residuoE = 0.0,           residuoEdaCelula = 0.0;    Element *aux;    if(malha->firstGridCell != NULL)    {        // Calcula os erros de todas as celulas ativas da malha        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if(celula->volumeFicticio == false && celula->active == true)            {                // Momento x ===================================================                aux = celula->firstElementMomentoX;                if(aux == NULL)                    return;                // Somando A_P u_P                residuoUdaCelula = aux->value * celula->uAtual;                // Somando A_viz u_viz                aux = aux->next;                while( aux != NULL )                {                    residuoUdaCelula += aux->value * aux->cell->uAtual;                    aux = aux->next;                }                // Subtraindo membro direito                residuoUdaCelula -= celula->b_MomentoX;                // Para fazer a norma 2                residuoU += AO_QUADRADO(residuoUdaCelula);                // Momento y ===================================================                aux = celula->firstElementMomentoY;                if(aux == NULL)                    return;                // Somando A_P v_P                residuoVdaCelula = aux->value * celula->vAtual;                // Somando A_viz v_viz                aux = aux->next;                while( aux != NULL )                {                    residuoVdaCelula += aux->value * aux->cell->vAtual;                    aux = aux->next;                }                // Subtraindo membro direito                residuoVdaCelula -= celula->b_MomentoY;                // Para fazer a norma 2                residuoV += AO_QUADRADO(residuoVdaCelula);                // Correcao de pressao =====================================                aux = celula->firstElementPressaoLinha;                if(aux == NULL)                    return;                // Soma A_P u_P                residuoPdaCelula = aux->value * celula->pLinha;                // Soma A_viz u_viz                aux = aux->next;                while( aux != NULL )                {                    residuoPdaCelula += aux->value * aux->cell->pLinha;                    aux = aux->next;                }                // Subtrai o membro direito                residuoPdaCelula -= celula->b_PressaoLinha;                // Para fazer a norma 2                residuoP += AO_QUADRADO(residuoPdaCelula);                //Energia =======================================================                aux = celula->firstElementEnergia;                if(aux == NULL)                    return;                //somando F_P T_P                residuoEdaCelula = aux->value * celula->TAtual;                //soma F_vizinhos e T_Vizinhos                aux = aux->next;                while(aux != NULL)                {                    residuoEdaCelula += aux->value * aux->cell->TAtual;                    aux = aux->next;                }                //subtraindo membro da direita                residuoEdaCelula -= celula->b_Energia;                // Para fazer a norma 2                residuoE += AO_QUADRADO(residuoEdaCelula);                // Massa ===============================================================                residuoMassa += AO_QUADRADO((celula->rhoAtual - celula->rhoAnterior) *                                    AO_QUADRADO(celula->faceLength) / malha->deltaT +                                    (celula->eastFaceRho * celula->eastFaceU -                                     celula->westFaceRho * celula->westFaceU +                                     celula->northFaceRho * celula->northFaceV -                                     celula->southFaceRho * celula->southFaceV)                                    * celula->faceLength);            }        }        // Calcula os erros de cada equacao        malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoP);        malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoU);        malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoV);        malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoE);        malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] = sqrt(residuoMassa);        // Atualiza maior residuo        if(malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > malha->maiorResiduo){            malha->maiorResiduo = malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        // Atualiza menor residuo        if(malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosP[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosU[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosV[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosE[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }        if(malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] < malha->menorResiduo        && malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS] > LIMITE_INFERIOR_RESIDUO){            malha->menorResiduo = malha->residuosM[iteracaoAtual % MAXITER_GRAFICO_RESIDUOS];        }    }    else    {        cout << "Na funcao calculaResiduos():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return;    }}