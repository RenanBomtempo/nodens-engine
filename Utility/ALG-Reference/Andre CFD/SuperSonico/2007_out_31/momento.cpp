/*  ========== momento.cpp =========    Contem funcoes para resolver as equacoes do momento    de Navier-Stokes*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                   calculaCoeficientesMomentoX()    Calcula os coeficientes A_p, A_e, A_w, A_n, A_s para cada celula, montando a matriz [A] do sistema associado 'a correcao de momento.    Parametros:        malha: apontador para a malha em questao;Criado por Andre STALTZ e Henrique dia 23/04/07Atualizado em 29/05/07 por Henrique______________________________________________________________________________*/int calculaCoeficientesMomentoX( Grid *malha ){    // Obs: Todos os deltaY/deltaX da discretizacao foram substituidos por 1,    // visto que a malha do ALG e' sempre quadrada    // Obs: Variaveis nas faces (mi, rho, u) PRECISAM ser os "*" (estimados)    Cell *celula;    short tipoFronteira;    // Coeficientes    double A_P = 0.0,           A_e = 0.0,           A_w = 0.0,           A_n = 0.0,           A_s = 0.0;    double S_P = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Evitar caso especial dos quatro cantos ficticios: nao entram no sistema            if( celula->active )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );                // Volume ficticio (fronteira oeste)                if( celula->direcaoFronteira == FRONTEIRA_OESTE && celula->volumeFicticio == true )                {                    // Se no OESTE for entrada de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_ENTRADA_MASSA)                    {                        // Entrada de massa, coeficientes importantes                        A_P = 1.0;                        A_e = 0.0;                        // Outros coeficientes                        A_n = 0.0; A_s = 0.0; A_w = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoX = valorCondicaoFronteira( celula->east, ID_VAR_U, 'w' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoX:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no oeste!" << endl;                    }                }                // Volume ficticio (fronteira leste)                else if( celula->direcaoFronteira == FRONTEIRA_LESTE && celula->volumeFicticio == true )                {                    // Se no LESTE for saida de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_SAIDA_MASSA)                    {                        // Saida de massa, coeficientes importantes                        A_P = 1.0;                        A_w = -1.0; //* (malha->M_oeste / malha->M_leste);                        // Outros coeficientes                        A_n = 0.0; A_s = 0.0; A_e = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoX = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoX:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no leste!" << endl;                    }                }                // Volume ficticio (fronteira norte)                else if( celula->direcaoFronteira == FRONTEIRA_NORTE && celula->volumeFicticio == true )                {                    // Se o NORTE for fronteira impermeavel (u prescrito)                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Fronteira impermeavel, coeficientes importantes                        A_P = 1.0;                        A_s = 1.0;                        // Outros coeficientes                        A_e = 0.0; A_w = 0.0; A_n = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoX = 2.0 * valorCondicaoFronteira( celula->south, ID_VAR_U, 'n' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoX:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no norte!" << endl;                    }                }                // Volume ficticio (fronteira sul)                else if( celula->direcaoFronteira == FRONTEIRA_SUL && celula->volumeFicticio )                {                    // Se o SUL for fronteira impermeavel (u prescrito)                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Fronteira impermeavel, coeficientes importantes                        A_P = 1.0;                        A_n = 1.0;                        // Outros coeficientes                        A_e = 0.0; A_w = 0.0; A_s = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoX = 2.0 * valorCondicaoFronteira( celula->north, ID_VAR_U, 's' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoX:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no sul!" << endl;                    }                }                // Volumes internos                else                {                    // Calculo dos coeficientes A das interfaces                    A_e = (0.5 - celula->eastFaceGamma) * (celula->eastFaceRho)                        * (celula->eastFaceU) * celula->faceLength                        - (celula->eastFaceMi) * (celula->eastFaceBeta);                    A_w = -1.0 * (0.5 + celula->westFaceGamma) * (celula->westFaceRho)                        * (celula->westFaceU) * celula->faceLength                        - (celula->westFaceMi) * (celula->westFaceBeta);                    A_n = (0.5 - celula->northFaceGamma) * (celula->northFaceRho)                         * (celula->northFaceV) * celula->faceLength                        - (celula->northFaceMi) * (celula->northFaceBeta);                    A_s = -1.0 * (0.5 + celula->southFaceGamma) * (celula->southFaceRho)                        * (celula->southFaceV) * celula->faceLength                        - (celula->southFaceMi) * (celula->southFaceBeta);                    S_P = (-celula->eastFaceMi * celula->eastFaceBeta                        -celula->westFaceMi * celula->westFaceBeta) / 3.0;                    // Calculo do coeficiente A principal                    A_P = - A_e - A_w - A_n - A_s - S_P                        + (celula->rhoAnterior) * (celula->faceLength / malha->deltaT) * celula->faceLength;                }                // Insere coeficiente principal na lista encadeada                celula->iniciaElement( A_P, &(celula->firstElementMomentoX) );                // Insere coeficientes dos vizinhos na mesma lista encadeada                celula->insereElement( A_e, celula->east, &(celula->firstElementMomentoX) );                celula->insereElement( A_w, celula->west, &(celula->firstElementMomentoX) );                celula->insereElement( A_n, celula->north, &(celula->firstElementMomentoX) );                celula->insereElement( A_s, celula->south, &(celula->firstElementMomentoX) );            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaCoeficientesMomentoX():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaCoeficientesMomentoX():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaCoeficientesMomentoY()    Calcula os coeficientes A_p^v, A_e^v, A_w^v, A_n^v, A_s^v para cada celula,montando a matriz [A] do sistema associado 'a correcao de pressao.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 24/04/07______________________________________________________________________________*/int calculaCoeficientesMomentoY( Grid *malha ){    // Obs: Todos os deltaY/deltaX da discretizacao foram substituidos por 1,    // visto que a malha do ALG e' sempre quadrada, como na funcao para o momento Y    // Obs: Aqui tambem, as variaveis nas faces (mi, rho, u) PRECISAM ser os "*" (estimados)    Cell *celula;    short tipoFronteira;    // Coeficientes    double A_P = 0.0,           A_e = 0.0,           A_w = 0.0,           A_n = 0.0,           A_s = 0.0;    double S_P = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Evitar caso especial dos quatro cantos ficticios: nao entram no sistema            if( celula->active )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_V );                // Volume ficticio (fronteira oeste)                if( celula->direcaoFronteira == FRONTEIRA_OESTE && celula->volumeFicticio == true ){                    // Se no OESTE for entrada de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_ENTRADA_MASSA)                    {                        // Entrada de massa, coeficientes importantes                        A_P = 1.0;                        A_e = 0.0;                        // Outros coeficientes                        A_n = 0.0; A_s = 0.0; A_w = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoY = valorCondicaoFronteira( celula->east, ID_VAR_V, 'w' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoY:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no oeste!" << endl;                    }                }                // Volume ficticio (fronteira leste)                else if( celula->direcaoFronteira == FRONTEIRA_LESTE && celula->volumeFicticio == true ){                    // Se no LESTE for saida de massa                    if(tipoFronteira == CONDICAO_FRONTEIRA_SAIDA_MASSA)                    {                        // Saida de massa, coeficientes importantes                        A_P = 1.0;                        A_w = -1.0;                        // Outros coeficientes                        A_n = 0.0; A_s = 0.0; A_e = 0.0;                        // B de acordo com 7.88 do Maliska                        celula->b_MomentoY = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoY:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no leste!" << endl;                    }                }                // Volume ficticio (fronteira norte)                else if( celula->direcaoFronteira == FRONTEIRA_NORTE && celula->volumeFicticio == true ){                    // Se o NORTE for fronteira impermeavel (v prescrito)                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Fronteira impermeavel, coeficientes importantes                        A_P = 1.0;                        A_s = 1.0;                         // Outros coeficientes                        A_e = 0.0; A_w = 0.0; A_n = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoY = 2.0 * valorCondicaoFronteira( celula->south, ID_VAR_V, 'n' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoY:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no norte!" << endl;                    }                }                // Volume ficticio (fronteira sul)                else if( celula->direcaoFronteira == FRONTEIRA_SUL && celula->volumeFicticio == true ){                    // Se o SUL for fronteira impermeavel (v prescrito)                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Fronteira impermeavel, coeficientes importantes                        A_P = 1.0;                        A_n = 1.0;                        // Outros coeficientes                        A_e = 0.0; A_w = 0.0; A_s = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_MomentoY = 2.0 * valorCondicaoFronteira( celula->north, ID_VAR_V, 's' );                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesMomentoY:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no sul!" << endl;                    }                }                // Volumes internos                else                {                    // Calculo dos coeficientes A das interfaces                    A_e = (0.5 - celula->eastFaceGamma) * (celula->eastFaceRho)                        * (celula->eastFaceU) * celula->faceLength                        - (celula->eastFaceMi) * (celula->eastFaceBeta);                    A_w = -1.0 * (0.5 + celula->westFaceGamma) * (celula->westFaceRho)                        * (celula->westFaceU) * celula->faceLength                        - (celula->westFaceMi) * (celula->westFaceBeta);                    A_n = (0.5 - celula->northFaceGamma) * (celula->northFaceRho)                        * (celula->northFaceV) * celula->faceLength                        - (celula->northFaceMi) * (celula->northFaceBeta);                    A_s = -1.0 * (0.5 + celula->southFaceGamma) * (celula->southFaceRho)                        * (celula->southFaceV) * celula->faceLength                        - (celula->southFaceMi) * (celula->southFaceBeta);                    S_P = (-celula->northFaceMi*celula->northFaceBeta                                        -celula->southFaceMi*celula->southFaceBeta) / 3.0;                    // Calculo do coeficiente A principal                    A_P = - A_e - A_w - A_n - A_s - S_P                        + (celula->rhoAnterior) * (celula->faceLength / malha->deltaT) * celula->faceLength;                }                // Insere coeficiente principal na lista encadeada                celula->iniciaElement( A_P, &(celula->firstElementMomentoY) );                // Insere coeficientes dos vizinhos na mesma lista encadeada                celula->insereElement( A_e, celula->east, &(celula->firstElementMomentoY) );                celula->insereElement( A_w, celula->west, &(celula->firstElementMomentoY) );                celula->insereElement( A_n, celula->north, &(celula->firstElementMomentoY) );                celula->insereElement( A_s, celula->south, &(celula->firstElementMomentoY) );            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaCoeficientesMomentoY():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaCoeficientesMomentoY():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaTermoFonteMomentoX()    Calcula o termo fonte do momento-x para cada celula, adicionando na matriz [B] do sistema associado ao momento x.    Parametros:        malha: apontador para a malha em questao;Criado por Andre STALTZ e Henrique dia 26/06/07______________________________________________________________________________*/int calculaTermoFonteMomentoX( Grid *malha ){    Cell *celula;    // Termo fonte    double S_c = 0.0,           S_e = 0.0,           S_w = 0.0;    double uVizLeste = 0.0,           uVizOeste = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;             celula != NULL;             celula = celula->next)        {            if( !celula->volumeFicticio )            {                obtemVariaveisVizinhas( celula, ID_VAR_U, NULL, NULL, &uVizLeste, &uVizOeste );                // Termo fonte                S_e = (celula->eastFaceMi) * (celula->eastFaceBeta) / 3.0;                S_w = (celula->westFaceMi) * (celula->westFaceBeta) / 3.0;                S_c = celula->faceLength *                      ( celula->northFaceMi * derivada('v', 'x', celula, 'n')                      - celula->southFaceMi * derivada('v', 'x', celula, 's') )                      + celula->faceLength * ( 2.0 / 3.0 )                      * ( -celula->eastFaceMi * derivada('v', 'y', celula, 'e')                      + celula->westFaceMi * derivada('v', 'y', celula, 'w') )                      - celula->faceLength * ( celula->eastFaceP - celula->westFaceP )                      + S_e * uVizLeste + S_w * uVizOeste;                // Insere o membro direito da equacao no vetor b da resolucao                celula->b_MomentoX = S_c + ( celula->rhoAnterior * celula->faceLength                                     * celula->uAnterior ) * (celula->faceLength / malha->deltaT);            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaTermoFonteMomentoX():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaTermoFonteMomentoX():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaTermoFonteMomentoY()    Calcula o termo fonte do momento-y para cada celula, adicionando na matriz [B] do sistema associado ao momento y.    Parametros:        malha: apontador para a malha em questao;Criado por Andre STALTZ e Henrique dia 26/06/07______________________________________________________________________________*/int calculaTermoFonteMomentoY( Grid *malha ){    Cell *celula;    // Termo fonte    double S_c = 0.0,           S_n = 0.0,           S_s = 0.0;    double vVizNorte = 0.0,           vVizSul = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;             celula != NULL;             celula = celula->next)        {            if( !celula->volumeFicticio )            {                obtemVariaveisVizinhas( celula, ID_VAR_V, &vVizNorte, &vVizSul, NULL, NULL );                // Termo fonte                S_n = (celula->northFaceMi) * (celula->northFaceBeta) / 3.0;                S_s = (celula->southFaceMi) * (celula->southFaceBeta) / 3.0;                S_c = celula->faceLength *                    ( celula->eastFaceMi * derivada('u','y',celula, 'e')                     - celula->westFaceMi * derivada('u','y',celula, 'w') )                    + celula->faceLength * ( 2.0 / 3.0 ) *                    ( -celula->northFaceMi * derivada('u','x',celula, 'n')                      + celula->southFaceMi * derivada('u','x',celula,'s') )                    - celula->faceLength * ( celula->northFaceP - celula->southFaceP )                    + S_n * vVizNorte + S_s * vVizSul;                // Insere o membro direito da equacao no vetor b da resolucao                celula->b_MomentoY = S_c + ( celula->rhoAnterior * celula->faceLength                             * celula->vAnterior ) * (celula->faceLength / malha->deltaT);            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaTermoFonteMomentoY():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaTermoFonteMomentoY():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaVelocidadesNasFaces()    Calcula o valor de u e v em todas as interfaces da malha, atraves da mediaponderada entre os valores de u nos centros das celulas correspondentes. O pesousado e' o coeficiente A_P da equacao do momento.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 25/04/07Atualizado pro Andre Staltz dia 29/05/07______________________________________________________________________________*/int calculaVelocidadesNasFaces( Grid *malha ){    // Celula da malha    Cell *celula;    // A_P de uma celula e da sua vizinha    double A_P_u = 0.0,           A_P_v = 0.0,           A_P_viz = 0.0;    double somatorioUVizinhosP = 0.0,           somatorioUVizinhosE = 0.0,           somatorioUVizinhosW = 0.0,           somatorioVVizinhosP = 0.0,           somatorioVVizinhosN = 0.0,           somatorioVVizinhosS = 0.0;    double S_e__P = 0.0,           S_w__P = 0.0,           S_e__E = 0.0,           S_w__E = 0.0,           S_e__W = 0.0,           S_w__W = 0.0,           S_n__P = 0.0,           S_s__P = 0.0,           S_n__N = 0.0,           S_s__N = 0.0,           S_n__S = 0.0,           S_s__S = 0.0;    double uVizLesteP = 0.0,           uVizOesteP = 0.0,           uVizLesteE = 0.0,           uVizOesteW = 0.0,           vVizNorteP = 0.0,           vVizSulP   = 0.0,           vVizNorteN = 0.0,           vVizSulS   = 0.0,           pVizLesteP = 0.0,           pVizOesteP = 0.0,           pVizNorteP = 0.0,           pVizSulP   = 0.0;    double termoFontePu = 0.0,           termoFonteEu = 0.0,           termoFonteWu = 0.0,           termoFontePv = 0.0,           termoFonteNv = 0.0,           termoFonteSv = 0.0,           Massa_P = 0.0,           Massa_E = 0.0,           Massa_W = 0.0,           Massa_N = 0.0,           Massa_S = 0.0;    Element *elementAux;    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if( celula->volumeFicticio == false && celula->active )            {                // Obtem o A_P^u e o A_P^v da celula atual ========================================                if( celula->firstElementMomentoX != NULL                ||  celula->firstElementMomentoY != NULL ) // Verifica erro                {                    A_P_u = celula->firstElementMomentoX->value;                    A_P_v = celula->firstElementMomentoY->value;                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula: " << celula->gridPosition << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem termos principais ========================================================                // Obtem somatorio dos u vizinhos de P com seus coeficientes                somatorioUVizinhosP = 0.0;                for(elementAux = celula->firstElementMomentoX->next;                    elementAux != NULL;                    elementAux = elementAux->next )                {                    somatorioUVizinhosP += elementAux->value * elementAux->cell->uAtual;                }                // Obtem somatorio dos v vizinhos de P com seus coeficientes                somatorioVVizinhosP = 0.0;                for(elementAux = celula->firstElementMomentoY->next;                    elementAux != NULL;                    elementAux = elementAux->next )                {                    somatorioVVizinhosP += elementAux->value * elementAux->cell->vAtual;                }                // Obtem termo fonte do momento x da celula central =================================                obtemVariaveisVizinhas( celula, ID_VAR_U, NULL, NULL, &uVizLesteP, &uVizOesteP );                S_e__P = (celula->eastFaceMi * celula->eastFaceBeta) / 3.0;                S_w__P = (celula->westFaceMi * celula->westFaceBeta) / 3.0;                termoFontePu = celula->faceLength *                    ( celula->northFaceMi * derivada('v', 'x', celula, 'n')                    - celula->southFaceMi * derivada('v', 'x', celula, 's') )                    + celula->faceLength * ( 2.0 / 3.0 )                    * ( -celula->eastFaceMi * derivada('v', 'y', celula, 'e')                    + celula->westFaceMi * derivada('v', 'y', celula, 'w') )                    + S_e__P * uVizLesteP + S_w__P * uVizOesteP;                // Obtem termo fonte do momento y da celula central =================================                obtemVariaveisVizinhas( celula, ID_VAR_V, &vVizNorteP, &vVizSulP, NULL, NULL );                S_n__P = (celula->northFaceMi) * (celula->northFaceBeta) / 3.0;                S_s__P = (celula->southFaceMi) * (celula->southFaceBeta) / 3.0;                termoFontePv = celula->faceLength *                    ( celula->eastFaceMi * derivada('u','y',celula, 'e')                     - celula->westFaceMi * derivada('u','y',celula, 'w') )                    + celula->faceLength * ( 2.0 / 3.0 ) *                    ( -celula->northFaceMi * derivada('u','x',celula, 'n')                      + celula->southFaceMi * derivada('u','x',celula,'s'))                    + S_n__P * vVizNorteP + S_s__P * vVizSulP;                // Obtem a massa da celula central =============================================                Massa_P = celula->rhoAnterior * AO_QUADRADO( celula->faceLength );                // ##### Calcula velocidade u na face leste #########################################                // Obtem o A_P_E                if( celula->east->firstElementMomentoX != NULL )                    A_P_viz = celula->east->firstElementMomentoX->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula->east: " << celula->east->gridPosition;                    return ERRO_ELEMENT_NULO;                }                if( celula->east->firstElementMomentoX != NULL )                {                    // Obtem somatorio dos u vizinhos de E com seus coeficientes                    somatorioUVizinhosE = 0.0;                    for(elementAux = celula->east->firstElementMomentoX->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        somatorioUVizinhosE += elementAux->value * elementAux->cell->uAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massas M_P e M_E no tempo anterior                Massa_E = celula->east->rhoAnterior * AO_QUADRADO( celula->east->faceLength );                obtemVariaveisVizinhas( celula, ID_VAR_P, NULL, NULL, &pVizLesteP, &pVizOesteP );                // Calcula u_e para essa celula                if(celula->east->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_e                    celula->I_e = - somatorioUVizinhosP - somatorioUVizinhosE                                + termoFontePu                                + ( (Massa_P + Massa_E) * celula->eastFaceUAnterior ) / (malha->deltaT)                                - celula->faceLength * ( pVizLesteP - celula->pAtual );                    celula->eastFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'e' );                }                else                {                    // Obtem L[S]_E =================================                    obtemVariaveisVizinhas( celula->east, ID_VAR_U, NULL, NULL, &uVizLesteE, NULL );                    S_e__E = (celula->east->eastFaceMi) * (celula->east->eastFaceBeta) / 3.0;                    S_w__E = (celula->east->westFaceMi) * (celula->east->westFaceBeta) / 3.0;                    termoFonteEu = celula->east->faceLength *                        ( celula->east->northFaceMi * derivada('v', 'x', celula->east, 'n')                        - celula->east->southFaceMi * derivada('v', 'x', celula->east, 's') )                        + celula->east->faceLength * ( 2.0 / 3.0 )                        * ( -celula->east->eastFaceMi * derivada('v', 'y', celula->east, 'e')                        + celula->east->westFaceMi * derivada('v', 'y', celula->east, 'w') )                        + S_e__E * uVizLesteE + S_w__E * celula->uAtual;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_e = - somatorioUVizinhosP - somatorioUVizinhosE                                + termoFontePu + termoFonteEu                                + ( (Massa_P + Massa_E) * celula->eastFaceUAnterior ) / (malha->deltaT)                                - celula->faceLength * ( pVizLesteP - celula->pAtual );                    celula->eastFaceU = celula->I_e / ( A_P_u + A_P_viz );                }                // ##### Calcula velocidade u na face oeste #########################################                // Obtem o A_P_W                if( celula->west->firstElementMomentoX != NULL )                    A_P_viz = celula->west->firstElementMomentoX->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula->west: " << celula->west->gridPosition;                    return ERRO_ELEMENT_NULO;                }                // Obtem somatorio dos u vizinhos de W com seus coeficientes                if( celula->west->firstElementMomentoX != NULL )                {                    somatorioUVizinhosW = 0.0;                    for(elementAux = celula->west->firstElementMomentoX->next;                        elementAux != NULL;                        elementAux = elementAux->next)                    {                        somatorioUVizinhosW += elementAux->value * elementAux->cell->uAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massas M_W no tempo anterior                Massa_W = celula->west->rhoAnterior * AO_QUADRADO( celula->west->faceLength );                // Calcula u_w para essa celula                if(celula->west->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_w                    celula->I_w = - somatorioUVizinhosP - somatorioUVizinhosW                                + termoFontePu                                + ( (Massa_P + Massa_W) * celula->westFaceUAnterior ) / (malha->deltaT)                                - celula->faceLength * ( celula->pAtual - pVizOesteP );                    celula->westFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'w' );                }                else                {                    // Obtem L[S]_W =================================                    obtemVariaveisVizinhas( celula->west, ID_VAR_U, NULL, NULL, NULL, &uVizOesteW );                    S_e__W = (celula->west->eastFaceMi) * (celula->west->eastFaceBeta) / 3.0;                    S_w__W = (celula->west->westFaceMi) * (celula->west->westFaceBeta) / 3.0;                    termoFonteWu = celula->west->faceLength *                        ( celula->west->northFaceMi * derivada('v', 'x', celula->west, 'n')                        - celula->west->southFaceMi * derivada('v', 'x', celula->west, 's') )                        + celula->west->faceLength * ( 2.0 / 3.0 )                        * ( -celula->west->eastFaceMi * derivada('v', 'y', celula->west, 'e')                        + celula->west->westFaceMi * derivada('v', 'y', celula->west, 'w') )                        + S_e__W * celula->uAtual + S_w__W * uVizOesteW;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_w = - somatorioUVizinhosP - somatorioUVizinhosW                                + termoFontePu + termoFonteWu                                + ( (Massa_P + Massa_W) * celula->westFaceUAnterior ) / (malha->deltaT)                                - celula->faceLength * ( celula->pAtual - pVizOesteP );                    celula->westFaceU = celula->I_w / ( A_P_u + A_P_viz );                }                // ##### Calcula velocidade v na face norte #########################################                // Obtem o A_P_N                if( celula->north->firstElementMomentoY != NULL )                    A_P_viz = celula->north->firstElementMomentoY->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula->north: " << celula->north->gridPosition;                    return ERRO_ELEMENT_NULO;                }                if( celula->north->firstElementMomentoY != NULL )                {                    // Obtem somatorio dos v vizinhos de N com seus coeficientes                    somatorioVVizinhosN = 0.0;                    for(elementAux = celula->north->firstElementMomentoY->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        somatorioVVizinhosN += elementAux->value * elementAux->cell->vAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massa M_N no tempo anterior                Massa_N = celula->north->rhoAnterior * AO_QUADRADO( celula->north->faceLength );                // Obtem o I_n pela formula 7.72 do livro do Maliska                obtemVariaveisVizinhas( celula, ID_VAR_P, &pVizNorteP, &pVizSulP, NULL, NULL );                // Calcula v_n para essa celula                if(celula->north->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_n                    celula->I_n = - somatorioVVizinhosP - somatorioVVizinhosN                                + termoFontePv                                + ( (Massa_P + Massa_N) * celula->northFaceVAnterior ) / (malha->deltaT)                                - celula->faceLength * ( pVizNorteP - celula->pAtual );                    celula->northFaceV = valorCondicaoFronteira( celula, ID_VAR_V, 'n' );                }                else                {                    // Obtem L[S]_N =================================                    obtemVariaveisVizinhas( celula->north, ID_VAR_V, &vVizNorteN, NULL, NULL, NULL );                    S_n__N = (celula->north->northFaceMi) * (celula->north->northFaceBeta) / 3.0;                    S_s__N = (celula->north->southFaceMi) * (celula->north->southFaceBeta) / 3.0;                    termoFonteNv = celula->north->faceLength *                        ( celula->north->eastFaceMi * derivada('u','y',celula->north, 'e')                        - celula->north->westFaceMi * derivada('u','y',celula->north, 'w') )                        + celula->north->faceLength * ( 2.0 / 3.0 ) *                        ( -celula->north->northFaceMi * derivada('u','x',celula->north, 'n')                        + celula->north->southFaceMi * derivada('u','x',celula->north, 's') )                        + S_n__N * vVizNorteN + S_s__N * celula->vAtual;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_n = - somatorioVVizinhosP - somatorioVVizinhosN                                + termoFontePv + termoFonteNv                                + ( (Massa_P + Massa_N) * celula->northFaceVAnterior ) / (malha->deltaT)                                - celula->faceLength * ( pVizNorteP - celula->pAtual );                    celula->northFaceV = celula->I_n / ( A_P_v + A_P_viz );                }                // ##### Calcula velocidade v na face sul #########################################                // Obtem o A_P_S                if( celula->south->firstElementMomentoY != NULL )                    A_P_viz = celula->south->firstElementMomentoY->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula->south: " << celula->south->gridPosition;                    return ERRO_ELEMENT_NULO;                }                if( celula->south->firstElementMomentoY != NULL )                {                    // Obtem somatorio dos v vizinhos de S com seus coeficientes                    somatorioVVizinhosS = 0.0;                    for(elementAux = celula->south->firstElementMomentoY->next;                        elementAux != NULL;                        elementAux = elementAux->next )                    {                        somatorioVVizinhosS += elementAux->value * elementAux->cell->vAtual;                    }                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem massa M_S no tempo anterior                Massa_S = celula->south->rhoAnterior * AO_QUADRADO( celula->south->faceLength );                // Calcula v_s para essa celula                if(celula->south->volumeFicticio)                {                    // Se a celula tem face com volume ficticio, exclui o termo fonte do I_s                    celula->I_s = - somatorioVVizinhosP - somatorioVVizinhosS                                + termoFontePv                                + ( (Massa_P + Massa_S) * celula->southFaceVAnterior ) / (malha->deltaT)                                - celula->faceLength * ( celula->pAtual - pVizSulP );                    celula->southFaceV = valorCondicaoFronteira( celula, ID_VAR_V, 's' );                }                else                {                    // Obtem L[S]_N =================================                    obtemVariaveisVizinhas( celula->south, ID_VAR_V, NULL, &vVizSulS, NULL, NULL );                    S_n__S = (celula->south->northFaceMi) * (celula->south->northFaceBeta) / 3.0;                    S_s__S = (celula->south->southFaceMi) * (celula->south->southFaceBeta) / 3.0;                    termoFonteSv = celula->south->faceLength *                        ( celula->south->eastFaceMi * derivada('u', 'y', celula->south, 'e')                         - celula->south->westFaceMi * derivada('u', 'y', celula->south, 'w') )                        + celula->south->faceLength * ( 2.0 / 3.0 ) *                        ( -celula->south->northFaceMi * derivada('u','x',celula->south, 'n')                         + celula->south->southFaceMi * derivada('u','x',celula->south, 's') )                        + S_n__S * celula->vAtual + S_s__S * vVizSulS;                    // Se a celula e' volume interno, calcula pela formula 7.72 do livro do Maliska                    celula->I_s = - somatorioVVizinhosP - somatorioVVizinhosS                                + termoFontePv + termoFonteSv                                + ( (Massa_P + Massa_S) * celula->southFaceVAnterior ) / (malha->deltaT)                                - celula->faceLength * ( celula->pAtual - pVizSulP );                    celula->southFaceV = celula->I_s / ( A_P_v + A_P_viz );                }/**////////////////////////////// ANTIGO: //////////////////////////////////////////*                // Obtem o A_P^u e o A_P^v da celula atual                if( celula->firstElementMomentoX != NULL                ||  celula->firstElementMomentoY != NULL ) // Verifica erro                {                    A_P_u = celula->firstElementMomentoX->value;                    A_P_v = celula->firstElementMomentoY->value;                }                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula: " << celula->gridPosition << endl;                    return ERRO_ELEMENT_NULO;                }                // --- Calcula velocidade v na face norte ---                // Obtem o A_P_N                if( celula->north->firstElementMomentoY != NULL )                    A_P_viz = celula->north->firstElementMomentoY->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula->north: " << celula->north->gridPosition;                    return ERRO_ELEMENT_NULO;                }                // Obtem o I_n                celula->I_n = A_P_v * celula->vAtual + A_P_viz * celula->north->vAtual;                // Calcula v_n para essa celula                celula->northFaceV = celula->I_n / ( A_P_v + A_P_viz );                // --- Calcula velocidade v na face sul ---                // Obtem o A_P_S                if( celula->south->firstElementMomentoY != NULL )                    A_P_viz = celula->south->firstElementMomentoY->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula->south: " << celula->south->gridPosition;                    return ERRO_ELEMENT_NULO;                }                // Obtem o I_s                celula->I_s = A_P_v * celula->vAtual + A_P_viz * celula->south->vAtual;                // Calcula v_s para essa celula                celula->southFaceV = celula->I_s / ( A_P_v + A_P_viz );                // --- Calcula velocidade u na face leste ---                // Obtem o A_P_E                if( celula->east->firstElementMomentoX != NULL )                    A_P_viz = celula->east->firstElementMomentoX->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    return ERRO_ELEMENT_NULO;                }                // Obtem o I_e por media ponderada                celula->I_e = A_P_u * celula->uAtual + A_P_viz * celula->east->uAtual;                // Calcula u_e para essa celula                celula->eastFaceU = celula->I_e / ( A_P_u + A_P_viz );                // --- Calcula velocidade na face oeste ---                // Obtem o A_P_W                if( celula->west->firstElementMomentoX != NULL )                    A_P_viz = celula->west->firstElementMomentoX->value;                else                {                    IMPRIMIR_ERRO_ELEMENT_NULO();                    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;                    cout << " celula->west: " << celula->west->gridPosition;                    return ERRO_ELEMENT_NULO;                }                // Obtem o I_w                celula->I_w = A_P_u * celula->uAtual + A_P_viz * celula->west->uAtual;                // Calcula u_w para essa celula                celula->westFaceU = celula->I_w / ( A_P_u + A_P_viz );  /**//////////////////////////// FIM DO ANTIGO //////////////////////////////////////////////////                // Caso especial para vizinhos de volumes ficticios =======================                // (condicao de fronteira)                if( celula->east->direcaoFronteira == FRONTEIRA_LESTE )                    celula->eastFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'e' );                if( celula->west->direcaoFronteira == FRONTEIRA_OESTE )                    celula->westFaceU = valorCondicaoFronteira( celula, ID_VAR_U, 'w' );                // Outras interfaces ======================================================                celula->southFaceU = interpolaVariavelFace( celula, ID_VAR_U, 's' );                celula->northFaceU = interpolaVariavelFace( celula, ID_VAR_U, 'n' );                celula->eastFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'e' );                celula->westFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'w' );            }            // Calcula velocidades nas faces dos ficticios            else if( celula->volumeFicticio && celula->active )            {                // Velocidade u                celula->northFaceU = interpolaVariavelFace( celula, ID_VAR_U, 'n' );                celula->southFaceU = interpolaVariavelFace( celula, ID_VAR_U, 's' );                celula->eastFaceU  = interpolaVariavelFace( celula, ID_VAR_U, 'e' );                celula->westFaceU  = interpolaVariavelFace( celula, ID_VAR_U, 'w' );                // Velocidade v                celula->northFaceV = interpolaVariavelFace( celula, ID_VAR_V, 'n' );                celula->southFaceV = interpolaVariavelFace( celula, ID_VAR_V, 's' );                celula->eastFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'e' );                celula->westFaceV  = interpolaVariavelFace( celula, ID_VAR_V, 'w' );            }        }        return SUCESSO;    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;        return ERRO_MALHA_VAZIA;    }    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    cout << "Erro acima ocorreu em calculaVelocidadesNasFaces()" << endl;    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  convergenciaVelocidades()   Verifica a convergencia das velovidades.   Parametros:       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 25/04/07.Atualizado por Henrique dia 09/07/09.______________________________________________________________________________*/int convergenciaVelocidades( Grid *malha ){    Cell *celula; // Celula da malha    double deltaU = 0.0,           maiorDeltaU = 0.0,           maiorU = 0.0,           menorU = 0.0,           erroVelocidadeU = 0.0,           deltaV = 0.0,           maiorDeltaV = 0.0,           maiorV = 0.0,           menorV = 0.0,           erroVelocidadeV = 0.0;    if(malha->firstGridCell != NULL)    {        // Calcula os erros na pressao de todas as celulas ativas        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if(celula->volumeFicticio == false && celula->active == true)            {                deltaU = fabs(celula->uAtual - celula->uIterAnterior);                if(deltaU > maiorDeltaU)                    maiorDeltaU = deltaU;                if(celula->uAtual > maiorU)                    maiorU = celula->uAtual;                if(celula->uAtual < menorU)                    menorU = celula->uAtual;                deltaV = fabs(celula->vAtual - celula->vIterAnterior);                if(deltaV > maiorDeltaV)                    maiorDeltaV = deltaV;                if(celula->vAtual > maiorV)                    maiorV = celula->vAtual;                if(celula->vAtual < menorV)                    menorV = celula->vAtual;            }        }        // Calcula o erro nas velocidades        if((maiorU - menorU) != 0.0)            erroVelocidadeU  = maiorDeltaU / (maiorU - menorU);        else        {            erroVelocidadeU = maiorDeltaU;        }        if((maiorV - menorV) != 0.0)            erroVelocidadeV  = maiorDeltaV / (maiorV - menorV);        else        {            erroVelocidadeV = maiorDeltaV;        }        // Verifica convergencia e retorna resultado        if ( erroVelocidadeU < COTA_VELOCIDADE_U && erroVelocidadeV < COTA_VELOCIDADE_V )            return SUCESSO;        else        {            return INSUCESSO;        }    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em convergenciaVelocidades()" << endl;        return ERRO_MALHA_VAZIA;    }}