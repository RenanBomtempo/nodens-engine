 /*  ========== derivadas.cpp =========    Derivadas du/dx, dv/dx, ...*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                                 derivada()           Calcula derivada horizontal de u em uma face solicitada.    Parametros:        celula: celula principal (central) do calculo.        face: em qual face a derivada sera' calculada.Criado por Andre STALTZ dia 25/04/07______________________________________________________________________________*/double derivada( char varDependente, char varIndependente, Cell *celula, char face ){    // Verifica validade do parametro    if( celula == NULL )    {        IMPRIMIR_ERRO_CELULA_INEXISTENTE();        return 0.0;    }    else if( varDependente != 'u' && varDependente != 'v' && varDependente != 'T' )    {        cout << "\nvarDependente = " << varDependente << endl;        IMPRIMIR_ERRO_VARDEPENDENTE_INEXISTENTE();        return 0.0;    }    else if( varIndependente != 'x' && varIndependente != 'y' )    {        cout << "\nvarIndependente = " << varIndependente << endl;        IMPRIMIR_ERRO_VARINDEPENDENTE_INEXISTENTE();        return 0.0;    }    // Nao podemos derivar fora do dominio    else if( celula->volumeFicticio )    {        IMPRIMIR_ERRO_DUDX_FORA();        return 0.0;            }    else    {        Cell *Leste, *Oeste,             *Norte, *Sul;        double deltaX = 1.0, deltaY = 1.0;        double valorDerivada = 0.0;        double uLeste = 0.0,               uOeste = 0.0,               vLeste = 0.0,               vOeste = 0.0,               TLeste = 0.0,               TOeste = 0.0;        double uNorte = 0.0,               uSul = 0.0,               vNorte = 0.0,               vSul = 0.0,               TNorte = 0.0,               TSul = 0.0;         bool westContribui = true,             eastContribui = true,             northContribui = true,             southContribui = true;        Leste = celula->east;        Oeste = celula->west;        Norte = celula->north;        Sul = celula->south;        if(varIndependente == 'x')        {          switch( face )          {             // ---------------------------------------------------------               case 'n': // -------------- FACE NORTE -------------------------------                              // ----- vizinho LESTE ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Leste->level > celula->level )                         while( ( Leste->type == 'w' ) &&                              ( Leste->singleConnector != 0 )                         )                         {   // DC1 e' o de cima, entre os do leste                         Leste = Leste->doubleConnector1;                         }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Leste->type == 'w' ) &&                              ( Leste->singleConnector != 0 )                         )                         {                         Leste = Leste->singleConnector;                         }                              // ----- vizinho OESTE ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Oeste->level > celula->level )                         while( ( Oeste->type == 'w' ) &&                              ( Oeste->singleConnector != 0 )                         )                         {   // DC1 e' o de cima, entre os do oeste                         Oeste = Oeste->doubleConnector1;                         }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Oeste->type == 'w' ) &&                              ( Oeste->singleConnector != 0 )                         )                         {                         Oeste = Oeste->singleConnector;                         }                         // Verifica se algum desses vizinhos e' fronteira                    if( (Leste->type == 'w') || Leste->volumeFicticio )                         eastContribui = false; // Isto denota que Leste e' invalido                         // Verifica se algum desses vizinhos e' fronteira                    if( (Oeste->type == 'w') || Oeste->volumeFicticio )                         westContribui = false; // Isto denota que Oeste e' invalido                         // Verifica se algum desses vizinhos nao compartilha face, isso                    // ocorre algumas vezes quando o vizinho e' maior que o atual                    // ( pode ser provado que nunca havera' simultaneamente                    //   Leste e Oeste invalidos )                    if( (Leste->type == 'b') && !Leste->volumeFicticio )                    {                         if( Leste->centerY + Leste->halfFaceLength !=                         celula->centerY + celula->halfFaceLength )                         eastContribui = false; // Isto denota que Leste e' invalido                    }                         if( (Oeste->type == 'b') && !Oeste->volumeFicticio )                    {                         if( Oeste->centerY + Oeste->halfFaceLength !=                         celula->centerY + celula->halfFaceLength )                         westContribui = false; // Isto denota que Oeste e' invalido                    }                         // Delta x total entre extremos (east--west ou atual--west ou east--atual)                    deltaX =                    (                         ( !westContribui )?                         0                         :                         (Oeste->halfFaceLength + celula->halfFaceLength)                    )                    +                    (                         ( !eastContribui )?                         0                         :                         (Leste->halfFaceLength + celula->halfFaceLength)                    );                         // --------- CALCULANDO DU_DX, DV_DX e DT_DX --------                    // Caso em que nem East nem West sao invalidos                    if( eastContribui && westContribui )                    {                         // Diferencas centradas                         if(varDependente == 'u')                         {                             valorDerivada = (Leste->northFaceU - Oeste->northFaceU)                                  / deltaX;                         }                         else if(varDependente == 'v')                         {                              valorDerivada = (Leste->northFaceV - Oeste->northFaceV)                                   / deltaX;                         }                         else if(varDependente == 'T')                         {                              valorDerivada = (Leste->northFaceT - Oeste->northFaceT)                                   / deltaX;                         }                         // Diferencas pra tras                         //du_dx = (celula->northFaceU - Oeste->northFaceU)                         //                / deltaX;                    }                    // Divisao de casos considerando East ou West invalidos                    if( !eastContribui )                    {                         if(varDependente == 'u')                         {                              valorDerivada = (celula->northFaceU - Oeste->northFaceU)                                   / deltaX;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (celula->northFaceV - Oeste->northFaceV)                                   / deltaX;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (celula->northFaceT - Oeste->northFaceT)                                   / deltaX;                         }                    }                    if( !westContribui )                    {                         if(varDependente == 'u')                         {                              valorDerivada = (Leste->northFaceU - celula->northFaceU)                                        / deltaX;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (Leste->northFaceV - celula->northFaceV)                                        / deltaX;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (Leste->northFaceT - celula->northFaceT)                                        / deltaX;                         }                    }               break;                              // ---------------------------------------------------------               case 's': // -------------- FACE SUL ---------------------------------                         // ----- vizinho LESTE ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Leste->level > celula->level )                         while( ( Leste->type == 'w' ) &&                              ( Leste->singleConnector != 0 )                         )                         {   // DC2 e' o de baixo, entre os do leste                         Leste = Leste->doubleConnector2;                         }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Leste->type == 'w' ) &&                              ( Leste->singleConnector != 0 )                         )                         {                         Leste = Leste->singleConnector;                         }                              // ----- vizinho OESTE ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Oeste->level > celula->level )                         while( ( Oeste->type == 'w' ) &&                              ( Oeste->singleConnector != 0 )                         )                         {   // DC2 e' o de baixo, entre os do oeste                         Oeste = Oeste->doubleConnector2;                         }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Oeste->type == 'w' ) &&                              ( Oeste->singleConnector != 0 )                         )                         {                         Oeste = Oeste->singleConnector;                         }                         // Verifica se algum desses vizinhos e' fronteira                    if( (Leste->type == 'w') || Leste->volumeFicticio )                         eastContribui = false; // Isto denota que Leste e' invalido                         // Verifica se algum desses vizinhos e' fronteira                    if( (Oeste->type == 'w') || Oeste->volumeFicticio )                         westContribui = false; // Isto denota que Oeste e' invalido                         // Verifica se algum desses vizinhos nao compartilha face, isso                    // ocorre algumas vezes quando o vizinho e' maior que o atual                    // ( pode ser provado que nunca havera' simultaneamente                    //   Leste e Oeste invalidos )                    if( (Leste->type == 'b') && !Leste->volumeFicticio )                    {                         if( Leste->centerY - Leste->halfFaceLength !=                         celula->centerY - celula->halfFaceLength )                         eastContribui = false; // Isto denota que Leste e' invalido                    }                         if( (Oeste->type == 'b') && !Oeste->volumeFicticio )                    {                         if( Oeste->centerY - Oeste->halfFaceLength !=                         celula->centerY - celula->halfFaceLength )                         westContribui = false; // Isto denota que Oeste e' invalido                    }                         // Delta x total entre extremos (east--west ou atual--west ou east--atual)                    deltaX =                    (                         ( !westContribui )?                         0                         :                         (Oeste->halfFaceLength + celula->halfFaceLength)                    )                    +                    (                         ( !eastContribui )?                         0                         :                         (Leste->halfFaceLength + celula->halfFaceLength)                    );                         // --------- CALCULANDO DU_DX, DV_DX e DT_DX --------                    // Caso em que nem East nem West sao invalidos                    if( eastContribui && westContribui )                    {                         // Diferencas centradas                         if(varDependente == 'u')                         {                              valorDerivada = (Leste->southFaceU - Oeste->southFaceU)                                        / deltaX;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (Leste->southFaceV - Oeste->southFaceV)                                        / deltaX;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (Leste->southFaceT - Oeste->southFaceT)                                        / deltaX;                         }                         // Diferencas pra tras                         //du_dx = (celula->southFaceU - Oeste->southFaceU)                         //                / deltaX;                    }                    // Divisao de casos considerando leste ou oeste invalidos                    if( !eastContribui )                    {                         if(varDependente == 'u')                         {                              valorDerivada = (celula->southFaceU - Oeste->southFaceU)                                        / deltaX;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (celula->southFaceV - Oeste->southFaceV)                                        / deltaX;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (celula->southFaceT - Oeste->southFaceT)                                        / deltaX;                         }                    }                    if( !westContribui )                    {                         if(varDependente == 'u')                         {                              valorDerivada = (Leste->southFaceU - celula->southFaceU)                                        / deltaX;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (Leste->southFaceV - celula->southFaceV)                                        / deltaX;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (Leste->southFaceT - celula->southFaceT)                                        / deltaX;                         }                    }               break;                         // ---------------------------------------------------------               case 'e': // -------------- FACE LESTE -------------------------------                    if(varDependente == 'u')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_U, NULL, NULL, &uLeste, NULL );                         // Retorna dudx_e                         return (uLeste - celula->uAtual) / celula->faceLength;                    }                    if(varDependente == 'v')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_V, NULL, NULL, &vLeste, NULL );                         // Retorna dvdx_e                         return (vLeste - celula->vAtual) / celula->faceLength;                    }                    if(varDependente == 'T')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_T, NULL, NULL, &TLeste, NULL );                         // Retorna dTdx_e                         return (TLeste - celula->TAtual) / celula->faceLength;                                        }               break;                              // ---------------------------------------------------------               case 'w': // -------------- FACE OESTE -------------------------------                    if(varDependente == 'u')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_U, NULL, NULL, NULL, &uOeste );                         // Retorna dudx_w                         return (celula->uAtual - uOeste) / celula->faceLength;                    }                    if(varDependente == 'v')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_V, NULL, NULL, NULL, &vOeste );                         // Retorna dvdx_w                         return (celula->vAtual - vOeste) / celula->faceLength;                    }                    if(varDependente == 'T')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_T, NULL, NULL, NULL, &TOeste );                         // Retorna dTdx_w                         return (celula->TAtual - TOeste) / celula->faceLength;                                        }                    break;                    default: // Outras faces                    IMPRIMIR_ERRO_FACE_INVALIDA_DERIVADA();                    return 0.0;               break;          }        }                 else if(varIndependente == 'y')        {          switch( face )          {                         // ---------------------------------------------------------               case 'e': // -------------- FACE LESTE -------------------------------                              // ----- vizinho NORTE ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Norte->level > celula->level )                         while( ( Norte->type == 'w' ) &&                              ( Norte->singleConnector != 0 )                         )                    {   // DC1 e' o da direita, entre os do norte                         Norte = Norte->doubleConnector1;                    }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Norte->type == 'w' ) &&                              ( Norte->singleConnector != 0 )                         )                         {                         Norte = Norte->singleConnector;                         }                              // ----- vizinho SUL ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Sul->level > celula->level )                         while( ( Sul->type == 'w' ) &&                              ( Sul->singleConnector != 0 )                         )                         {   // DC1 e' o da direita, entre os do sul                         Sul = Sul->doubleConnector1;                         }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Sul->type == 'w' ) &&                              ( Sul->singleConnector != 0 )                         )                         {                         Sul = Sul->singleConnector;                         }                         // Verifica se algum desses vizinhos e' fronteira                    if( (Norte->type == 'w') || Norte->volumeFicticio )                         northContribui = false; // Isto denota que Norte e' invalido                         // Verifica se algum desses vizinhos e' fronteira                    if( (Sul->type == 'w') || Sul->volumeFicticio )                         southContribui = false; // Isto denota que Sul e' invalido                         // Verifica se algum desses vizinhos nao compartilha face, isso                    // ocorre algumas vezes quando o vizinho e' maior que o atual                    // ( pode ser provado que nunca havera' simultaneamente                    //   Norte e Sul invalidos )                    if( (Norte->type == 'b') && !Norte->volumeFicticio )                    {                         if( Norte->centerX + Norte->halfFaceLength !=                         celula->centerX + celula->halfFaceLength )                         northContribui = false; // Isto denota que Norte e' invalido                    }                         if( (Sul->type == 'b') && !Sul->volumeFicticio )                    {                         if( Sul->centerX + Sul->halfFaceLength !=                         celula->centerX + celula->halfFaceLength )                         southContribui = false; // Isto denota que Sul e' invalido                    }                         // Delta y total entre extremos (norte--sul ou atual--sul ou norte--atual)                    deltaY =                    (                         ( !northContribui )?                         0                         :                         (Norte->halfFaceLength + celula->halfFaceLength)                    )                    +                    (                         ( !southContribui )?                         0                         :                         (Sul->halfFaceLength + celula->halfFaceLength)                    );                         // --------- CALCULANDO DU_DY, DV_DY e DT_DY --------                    // Caso em que nem North nem South sao invalidos                    if( northContribui && southContribui )                    {                         // Diferencas centradas                         if(varDependente == 'u')                         {                              valorDerivada = (Norte->eastFaceU - Sul->eastFaceU)                                   / deltaY;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (Norte->eastFaceV - Sul->eastFaceV)                                   / deltaY;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (Norte->eastFaceT - Sul->eastFaceT)                                   / deltaY;                         }                         // Diferencas pra tras                         //du_dy = (celula->eastFaceU - Sul->eastFaceU)                         //               / deltaY;                    }                    // Divisao de casos considerando North ou South invalidos                    if( !northContribui )                    {                             if(varDependente == 'u')                         {                              valorDerivada = (celula->eastFaceU - Sul->eastFaceU)                                   / deltaY;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (celula->eastFaceV - Sul->eastFaceV)                                   / deltaY;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (celula->eastFaceT - Sul->eastFaceT)                                   / deltaY;                         }                    }                    if( !southContribui )                    {                         if(varDependente == 'u')                         {                              valorDerivada = (Norte->eastFaceU - celula->eastFaceU)                                   / deltaY;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (Norte->eastFaceV - celula->eastFaceV)                                   / deltaY;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (Norte->eastFaceT - celula->eastFaceT)                                   / deltaY;                         }                    }               break;                              // ---------------------------------------------------------               case 'w': // -------------- FACE OESTE -------------------------------                              // ----- vizinho NORTE ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Norte->level > celula->level )                         while( ( Norte->type == 'w' ) &&                              ( Norte->singleConnector != 0 )                         )                         {   // DC2 e' o da esquerda, entre os do norte                         Norte = Norte->doubleConnector2;                         }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Norte->type == 'w' ) &&                              ( Norte->singleConnector != 0 )                         )                         {                         Norte = Norte->singleConnector;                         }                              // ----- vizinho SUL ------                    // Buscar vizinho preto quando ele e' menor que a celula atual                    if ( Sul->level > celula->level )                         while( ( Sul->type == 'w' ) &&                              ( Sul->singleConnector != 0 )                         )                         {   // DC2 e' o da esquerda, entre os do sul                         Sul = Sul->doubleConnector2;                         }                    // Buscar vizinho preto quando ele e' maior que a celula atual                    else                         while( ( Sul->type == 'w' ) &&                              ( Sul->singleConnector != 0 )                         )                         {                         Sul = Sul->singleConnector;                         }                         // Verifica se algum desses vizinhos e' fronteira                    if( (Norte->type == 'w') || Norte->volumeFicticio )                         northContribui = false; // Isto denota que Norte e' invalido                         // Verifica se algum desses vizinhos e' fronteira                    if( (Sul->type == 'w') || Sul->volumeFicticio )                         southContribui = false; // Isto denota que Sul e' invalido                         // Verifica se algum desses vizinhos nao compartilha face, isso                    // ocorre algumas vezes quando o vizinho e' maior que o atual                    // ( pode ser provado que nunca havera' simultaneamente                    //   Norte e Sul invalidos )                    if( (Norte->type == 'b') && !Norte->volumeFicticio )                    {                         if( Norte->centerX - Norte->halfFaceLength !=                         celula->centerX - celula->halfFaceLength )                         northContribui = false; // Isto denota que Norte e' invalido                    }                         if( (Sul->type == 'b') && !Sul->volumeFicticio )                    {                         if( Sul->centerX - Sul->halfFaceLength !=                         celula->centerX - celula->halfFaceLength )                         southContribui = false; // Isto denota que Sul e' invalido                    }                         // Delta y total entre extremos (norte--sul ou atual--sul ou norte--atual)                    deltaY =                    (                         ( !northContribui )?                         0                         :                         (Norte->halfFaceLength + celula->halfFaceLength)                    )                    +                    (                         ( !southContribui )?                         0                         :                         (Sul->halfFaceLength + celula->halfFaceLength)                    );                         // --------- CALCULANDO DU_DY, DV_DY e DT_DY --------                    // Caso em que nem North nem South sao invalidos                    if( northContribui && southContribui )                    {                         // Diferencas centradas                         if(varDependente == 'u')                         {                              valorDerivada = (Norte->westFaceU - Sul->westFaceU)                                   / deltaY;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (Norte->westFaceV - Sul->westFaceV)                                   / deltaY;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (Norte->westFaceT - Sul->westFaceT)                                   / deltaY;                         }                         // Diferencas pra tras                         //du_dy = (celula->westFaceU - Sul->westFaceU)                         //                / deltaY;                    }                    // Divisao de casos considerando North ou South invalidos                    if( !northContribui )                    {                         if(varDependente == 'u')                         {                              valorDerivada = (celula->westFaceU - Sul->westFaceU)                                   / deltaY;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (celula->westFaceV - Sul->westFaceV)                                   / deltaY;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (celula->westFaceT - Sul->westFaceT)                                   / deltaY;                         }                    }                    if( !southContribui )                    {                         if(varDependente == 'u')                         {                              valorDerivada = (Norte->westFaceU - celula->westFaceU)                                   / deltaY;                         }                         if(varDependente == 'v')                         {                              valorDerivada = (Norte->westFaceV - celula->westFaceV)                                   / deltaY;                         }                         if(varDependente == 'T')                         {                              valorDerivada = (Norte->westFaceT - celula->westFaceT)                                   / deltaY;                         }                    }               break;                              // ---------------------------------------------------------               case 'n': // -------------- FACE NORTE -------------------------------                    if(varDependente == 'u')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_U, &uNorte, NULL, NULL, NULL );                         // Retorna dudy_n                         return (uNorte - celula->uAtual) / celula->faceLength;                    }                    if(varDependente == 'v')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_V, &vNorte, NULL, NULL, NULL );                         // Retorna dvdy_n                         return (vNorte - celula->vAtual) / celula->faceLength;                    }                    if(varDependente == 'T')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_T, &TNorte, NULL, NULL, NULL );                         // Retorna dTdy_n                         return (TNorte - celula->TAtual) / celula->faceLength;                    }               break;                              // ---------------------------------------------------------               case 's': // -------------- FACE SUL ---------------------------------                    if(varDependente == 'u')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_U, NULL, &uSul, NULL, NULL );                         // Retorna dudy_s                         return (celula->uAtual - uSul) / celula->faceLength;                    }                    if(varDependente == 'v')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_V, NULL, &vSul, NULL, NULL );                         // Retorna dvdy_s                         return (celula->vAtual - vSul) / celula->faceLength;                    }                    if(varDependente == 'T')                    {                         obtemVariaveisVizinhas( celula, ID_VAR_T, NULL, &TSul, NULL, NULL );                         // Retorna dTdy_s                         return (celula->TAtual - TSul) / celula->faceLength;                    }               break;                    default: // Outras faces                    IMPRIMIR_ERRO_FACE_INVALIDA_DERIVADA();                    return 0.0;               break;          }        }        return valorDerivada;    }    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    cout << "\nFuncao derivada()";    return 0.0;}