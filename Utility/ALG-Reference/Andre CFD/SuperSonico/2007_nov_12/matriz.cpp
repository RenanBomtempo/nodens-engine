/*  ========== matriz.cpp ====================    Funcoes relacionadas a resolucao de    sistemas lineares e operacoes com matrizes*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                    gradienteBiconjugadoEstabilizado()    Biconjugate gradient stabilized method for nonsymmetric matrices.    Notation close to the one used in the original van der Vorst pape.______________________________________________________________________________*/int gradienteBiconjugadoEstabilizado( Grid *malha, short id_variavel ){    double error = 0.0,      //Euclidean norm of second res?due r after each iteration.           tolerance, //Error tolerance           rho = 1.0,           rhoNew,           alpha = 1.0,           beta,           omega = 1.0,           r_ScalarAp,           rScalarR = 0.0,           sScalarAs,           AsScalarAs;    int numberOfIterations = 0;    Cell *gridCell;    Element *element;    // Verificar se o sistema da variavel solicitada existe    if( id_variavel != ID_VAR_U    &&  id_variavel != ID_VAR_V    &&  id_variavel != ID_VAR_PLINHA    &&  id_variavel != ID_VAR_T )    {        IMPRIMIR_ERRO_ID_VARIAVEL_INEXISTENTE();        cout << "Erro acima ocorreu em gradienteBiconjugadoEstabilizado()" << endl;        return ERRO_ID_VAR_INEXISTENTE;    }    // Ajusta a tolerancia de erro de acordo com o sistema a ser calculado    if( id_variavel == ID_VAR_PLINHA )        tolerance = COTA_GRADCONJUGADO_PRESSAO;    else if( id_variavel == ID_VAR_T )        tolerance = COTA_GRADCONJUGADO_TEMPERATURA;    else        tolerance = COTA_GRADCONJUGADO;    //__________________________________________________________________________    //Computes vector A*x in order to compute initial residue r = b - Ax,    //and then rScalarR = r^T * r. Uses Ap to store Ax.    //Sets second residual vector r_ as r (r_ is an arbitrary vector, not    //orthogonal to r).    gridCell = malha->firstGridCell;    while( gridCell != NULL )    {        if(gridCell->active == true)        {            gridCell->Ap = 0.0;            switch( id_variavel ) // Escolher qual o sistema sera' resolvido            {                case ID_VAR_U: // Velocidade U (horizontal) ======                    element = gridCell->firstElementMomentoX;                break;                case ID_VAR_V: // Velocidade V (vertical) ========                    element = gridCell->firstElementMomentoY;                break;                case ID_VAR_PLINHA: // Pressao (correcao) ========================                    element = gridCell->firstElementPressaoLinha;                break;                case ID_VAR_T: // Energia (temperatura) ========================                    element = gridCell->firstElementEnergia;                break;            }            while( element != NULL )            {                switch( id_variavel ) // Escolher qual o sistema sera' resolvido                {                    case ID_VAR_U: // Velocidade U (horizontal) ======                        gridCell->Ap += element->value * element->cell->uAtual;                    break;                    case ID_VAR_V: // Velocidade V (vertical) ========                        gridCell->Ap += element->value * element->cell->vAtual;                    break;                    case ID_VAR_PLINHA: // Pressao ========================                        gridCell->Ap += element->value * element->cell->pLinha;                    break;                    case ID_VAR_T: // Energia (temperatura) ========================                        gridCell->Ap += element->value * element->cell->TAtual;                    break;                }                element = element->next;            }            switch( id_variavel ) // Escolher qual o sistema sera' resolvido            {                case ID_VAR_U: // Velocidade U (horizontal) ======                    gridCell->r = gridCell->b_MomentoX - gridCell->Ap;                break;                case ID_VAR_V: // Velocidade V (vertical) ========                    gridCell->r = gridCell->b_MomentoY - gridCell->Ap;                break;                case ID_VAR_PLINHA: // Pressao ========================                    gridCell->r = gridCell->b_PressaoLinha - gridCell->Ap;                break;                case ID_VAR_T: // Energia (temperatura) ========================                    gridCell->r = gridCell->b_Energia - gridCell->Ap;                break;            }            gridCell->r_ = gridCell->r; //r_ should never be orthogonal to r.            rScalarR += gridCell->r * gridCell->r;            gridCell->Ap = 0.0;//Resets Ap to 0.        }        gridCell = gridCell->next;    }    error = sqrt(rScalarR);    //__________________________________________________________________________    //Biconjugate gradient stabilized iterations.    while( (error > tolerance    && numberOfIterations < LIMITE_ITERACOES_GRADBICONJUGADO      && rho > tolerance     && omega > tolerance) ) //  || numberOfIterations < 0 )    {        // ______________________________________________________________________        // Computes rhoNew = < r_, r >.        gridCell = malha->firstGridCell;        rhoNew = 0.0;        while( gridCell != NULL )        {            if(gridCell->active == true)            {                rhoNew += gridCell->r_ * gridCell->r;            }            gridCell = gridCell->next;        }        // ______________________________________________________________________        // Computes beta and updates rho.        beta = (rhoNew / rho) * (alpha / omega);        rho = rhoNew;        // ______________________________________________________________________        // Updates p.        gridCell = malha->firstGridCell;        while( gridCell != NULL )        {            if(gridCell->active == true)            {                gridCell->p = gridCell->r                            + beta * ( gridCell->p - omega * gridCell->Ap );            }            gridCell = gridCell->next;        }        // ______________________________________________________________________        // Computes Ap and < r_, Ap >.        gridCell = malha->firstGridCell;        r_ScalarAp = 0.0;        while( gridCell != NULL )        {            if(gridCell->active == true)            {                gridCell->Ap = 0.0;                switch( id_variavel ) // Escolher qual o sistema sera' resolvido                {                    case ID_VAR_U: // Velocidade U (horizontal) ======                        element = gridCell->firstElementMomentoX;                    break;                    case ID_VAR_V: // Velocidade V (vertical) ========                        element = gridCell->firstElementMomentoY;                    break;                    case ID_VAR_PLINHA: // Pressao ========================                        element = gridCell->firstElementPressaoLinha;                    break;                    case ID_VAR_T: // Energia (temperatura) ========================                        element = gridCell->firstElementEnergia;                    break;                }                while( element != NULL )                {                    gridCell->Ap += element->value * element->cell->p;                    element = element->next;                }                r_ScalarAp += gridCell->r_ * gridCell->Ap;            }            gridCell = gridCell->next;        }        //______________________________________________________________________        //Computes alpha.        alpha = rhoNew/r_ScalarAp;        //______________________________________________________________________        //Updates second residue s = r - alpha*Ap and sScalarS.        gridCell = malha->firstGridCell;        while( gridCell != NULL )        {            if(gridCell->active == true)            {                gridCell->s = gridCell->r - alpha * gridCell->Ap;            }            gridCell = gridCell->next;        }        // ______________________________________________________________________        // Computes As, sScalarAs and AsScalarAs.        gridCell = malha->firstGridCell;        sScalarAs = 0.0;        AsScalarAs = 0.0;        while( gridCell != NULL )        {            if(gridCell->active == true)            {                gridCell->As = 0.0;                switch( id_variavel ) // Escolher qual o sistema sera' resolvido                {                    case ID_VAR_U: // Velocidade U (horizontal) ======                        element = gridCell->firstElementMomentoX;                    break;                    case ID_VAR_V: // Velocidade V (vertical) ========                        element = gridCell->firstElementMomentoY;                    break;                    case ID_VAR_PLINHA: // Pressao ========================                        element = gridCell->firstElementPressaoLinha;                    break;                    case ID_VAR_T: // Energia (temperatura) ========================                        element = gridCell->firstElementEnergia;                    break;                }                while( element != NULL )                {                    gridCell->As += element->value * element->cell->s;                    element = element->next;                }                sScalarAs += gridCell->s * gridCell->As;                AsScalarAs += gridCell->As * gridCell->As;            }            gridCell = gridCell->next;        }        // ______________________________________________________________________        // Computes omega.        omega = (AsScalarAs != 0) ? (sScalarAs / AsScalarAs) : 0.0;       // isto e' questionavel!        // ______________________________________________________________________        // Updates solution x = x + alpha*p + omega*s and computes        // residue r = s - omega*As and <r,r>.        gridCell = malha->firstGridCell;        rScalarR = 0.0;        while( gridCell != NULL )        {            if( gridCell->active == true )            {                switch( id_variavel ) // Escolher qual o sistema sera' resolvido                {                    case ID_VAR_U: // Velocidade U (horizontal) ======                        gridCell->uAtual += alpha*gridCell->p + omega*gridCell->s;                    break;                    case ID_VAR_V: // Velocidade V (vertical) ========                        gridCell->vAtual += alpha*gridCell->p + omega*gridCell->s;                    break;                    case ID_VAR_PLINHA: // Pressao ========================                        gridCell->pLinha += alpha*gridCell->p + omega*gridCell->s;                    break;                    case ID_VAR_T: // Energia (temperatura) ========================                        gridCell->TAtual += alpha*gridCell->p + omega*gridCell->s;                    break;                }                gridCell->r = gridCell->s - omega * gridCell->As;                rScalarR += gridCell->r * gridCell->r;            }            gridCell = gridCell->next;        }        // ______________________________________________________________________        // Updates error.        error = sqrt(rScalarR);        numberOfIterations++;    }    cout << "Custo do gradiente biconjugado estabilizado: " << numberOfIterations << " iteracoes.";        if( numberOfIterations == LIMITE_ITERACOES_GRADBICONJUGADO )        cout << " (maximo estabelecido)";            cout << endl;    return SUCESSO;} // end gradienteBiconjugadoEstabilizado() function./*______________________________________________________________________________                              gradienteConjugado()    Resolve o sistema A x = b (de algum sistema dado pelo parametro) por gradiente conjugado.    Parametros:         malha: ponteiro para o Grid contendo as celulas e as matrizes a serem resolvidas         id_variavel: um identificador para saber qual variavel sera' resolvida.Criado por Andre STALTZ dia 08/05/07______________________________________________________________________________*/int gradienteConjugado( Grid *malha, short id_variavel ) {    double error = 0.0,      //Norma do residuo (b - Ax) apos cada iteracao           pError = 1.0,           rTr,           r1Tr1,           pTAp,           alpha,           beta,           normR = 0.0,            normPP1 = 0.0,           precision = COTA_GRADCONJUGADO; // Precisao minima cujo o erro nao pode ultrapassar    int maxIteracoes = malha->numberOfCells,        iteracoes = 0;    Cell *gridCell;    Element *element;    // Verificar se o sistema da variavel solicitada existe    if( id_variavel != ID_VAR_U    &&  id_variavel != ID_VAR_V    &&  id_variavel != ID_VAR_PLINHA )    {        IMPRIMIR_ERRO_ID_VARIAVEL_INEXISTENTE();        cout << "Erro acima ocorreu em gradienteConjugado()" << endl;        return ERRO_ID_VAR_INEXISTENTE;    }            //__________________________________________________________________________        //Computes vector A*x, residue r = b - Ax, scalar rTr = r^T * r and     //sets initial search direction p.        gridCell = malha->firstGridCell;     rTr = 0.0;       while( gridCell != 0 )    {        if( gridCell->active )        {            gridCell->Ax = 0.0;// Para cada celula da malha (correspondendo a uma linha da matriz)            switch( id_variavel ) // Escolher qual o sistema sera' resolvido            {                case ID_VAR_U: // Velocidade U (horizontal) ======                    element = gridCell->firstElementMomentoX;                break;                        case ID_VAR_V: // Velocidade V (vertical) ========                    element = gridCell->firstElementMomentoY;                break;                case ID_VAR_PLINHA: // Pressao ========================                    element = gridCell->firstElementPressaoLinha;                break;            }                        while( element != NULL )            {                switch( id_variavel ) // Escolher qual o sistema sera' resolvido                {                    case ID_VAR_U: // Velocidade U (horizontal) ======                        gridCell->Ax += element->value * element->cell->uAtual;                    break;                            case ID_VAR_V: // Velocidade V (vertical) ========                        gridCell->Ax += element->value * element->cell->vAtual;                    break;                    case ID_VAR_PLINHA: // Pressao ========================                        gridCell->Ax += element->value * element->cell->pLinha;                    break;                }                element = element->next;                       }            switch( id_variavel ) // Escolher qual o sistema sera' resolvido            {                case ID_VAR_U: // Velocidade U (horizontal) ======                    gridCell->r = gridCell->b_MomentoX - gridCell->Ax;                break;                        case ID_VAR_V: // Velocidade V (vertical) ========                    gridCell->r = gridCell->b_MomentoY - gridCell->Ax;                break;                case ID_VAR_PLINHA: // Pressao ========================                    gridCell->r = gridCell->b_PressaoLinha - gridCell->Ax;                break;            }            rTr += gridCell->r * gridCell->r;            gridCell->p = gridCell->r;            if( fabs(gridCell->r) > error )                error = fabs(gridCell->r);        }            gridCell = gridCell->next;    }        //__________________________________________________________________________    //Conjugate gradient iterations.    if( error >= precision )    {        while( (pError >= precision)  &&                (iteracoes < maxIteracoes) )        {            pError = 0.0;            normPP1 = 0.0;            //__________________________________________________________________            // Computes Ap and pTAp. Uses Ax to store Ap.            gridCell = malha->firstGridCell;            pTAp = 0.0;                while( gridCell != NULL )            {                if( gridCell->active )                {                    gridCell->Ax = 0.0;                    switch( id_variavel ) // Escolher qual o sistema sera' resolvido                    {                        case ID_VAR_U: // Velocidade U (horizontal) ======                            element = gridCell->firstElementMomentoX;                        break;                                case ID_VAR_V: // Velocidade V (vertical) ========                            element = gridCell->firstElementMomentoY;                        break;                        case ID_VAR_PLINHA: // Pressao ========================                            element = gridCell->firstElementPressaoLinha;                        break;                    }                    while( element != NULL )                    {                        gridCell->Ax += element->value * element->cell->p;                        element = element->next;                    }                    pTAp += gridCell->p * gridCell->Ax;                }                    gridCell = gridCell->next;            }            //__________________________________________________________________            // Computes alpha.            alpha = rTr/pTAp;            //__________________________________________________________________            // Computes new value of solution: u = u + alpha*p.            gridCell = malha->firstGridCell;            while( gridCell != NULL )            {                if( gridCell->active )                {                    switch( id_variavel ) // Escolher qual o sistema sera' resolvido                    {                        case ID_VAR_U: // Velocidade U (horizontal) ======                            gridCell->uAtual += alpha * gridCell->p;                        break;                        case ID_VAR_V: // Velocidade V (vertical) ========                            gridCell->vAtual += alpha * gridCell->p;                        break;                        case ID_VAR_PLINHA: // Pressao ========================                            gridCell->pLinha += alpha * gridCell->p;                        break;                    }                }                gridCell = gridCell->next;            }            //__________________________________________________________________            //Upgrades residue r1 = r - alpha*Ap and computes r1Tr1 = r1^T * r1.             gridCell = malha->firstGridCell;            r1Tr1 = 0.0;                while( gridCell != NULL )            {                if( gridCell->active )                {                    gridCell->r -= alpha * gridCell->Ax;                    r1Tr1 += gridCell->r * gridCell->r;                }                gridCell = gridCell->next;            }            //__________________________________________________________________            //Computes beta.            beta = r1Tr1/rTr;            //__________________________________________________________________            //Computes vector p1 = r1 + beta*p and uses it to upgrade p.            gridCell = malha->firstGridCell;            while( gridCell != NULL )            {                if( gridCell->active )                {                    gridCell->p1 = gridCell->r + beta * gridCell->p;                    if ( fabs(gridCell->r) > normR )                         normR = fabs(gridCell->r);                    if ( fabs(gridCell->p - gridCell->p1) > normPP1 )                         normPP1 = fabs(gridCell->p - gridCell->p1);                    gridCell->p = gridCell->p1;                }                gridCell = gridCell->next;            }            if( normR < precision )                pError = 0.0;            else if( normPP1 > pError )                pError = normPP1;            //__________________________________________________________________            //Upgrades rTr.            rTr = r1Tr1;            iteracoes++;        }    cout << "Custo do gradiente conjugado: " << 100.0*(                                                            ( (double)iteracoes )                                                          / ( (double)malha->numberOfCells )                                                      )         << " %" << endl;    }    return SUCESSO;}// Imprime a matriz de alguma variavelvoid imprimeMatriz( Grid *malha, short id_variavel ){    Cell *celula;    Element *element;    // Verifica se a id de variavel solicitada tem matriz correspondente    if( id_variavel != ID_VAR_U    &&  id_variavel != ID_VAR_V    &&  id_variavel != ID_VAR_PLINHA    &&  id_variavel != ID_VAR_T )    {        IMPRIMIR_ERRO_ID_VARIAVEL_INEXISTENTE();        cout << "Erro acima ocorreu em imprimeMatriz()" << endl;    }    if(malha->firstGridCell != NULL)    {        switch( id_variavel ) // Escolher qual o sistema sera' resolvido        {            case ID_VAR_U: // Velocidade U (horizontal) ======                cout << "\n\nImprimindo a matriz da velocidade horizontal (u)\n";            break;            case ID_VAR_V: // Velocidade V (vertical) ========                cout << "\n\nImprimindo a matriz da velocidade vertical (v)\n";            break;            case ID_VAR_PLINHA: // Pressao ========================                cout << "\n\nImprimindo a matriz da pressao\n";            break;            case ID_VAR_T: // Energia (temperatura) ========================                cout << "\n\nImprimindo a matriz da energia\n";            break;        }        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if( celula->active )            {                cout << endl;                switch( id_variavel ) // Escolher qual o sistema sera' resolvido                {                    case ID_VAR_U: // Velocidade U (horizontal) ======                        element = celula->firstElementMomentoX;                    break;                    case ID_VAR_V: // Velocidade V (vertical) ========                        element = celula->firstElementMomentoY;                    break;                    case ID_VAR_PLINHA: // Pressao ========================                        element = celula->firstElementPressaoLinha;                    break;                    case ID_VAR_T: // Energia (temperatura) ========================                        element = celula->firstElementEnergia;                    break;                }                for( ; element != NULL; element = element->next )                {                    cout << "(" << celula->gridPosition                        << ", " << element->column << ")"                        << "=" << element->value << "   ";                    cout << "T = " << celula->TAtual << endl;                }            }        }    }    else    {        IMPRIMIR_ERRO_MALHA_VAZIA();        cout << "Erro acima ocorreu em ImprimeMatriz()" << endl;    }}