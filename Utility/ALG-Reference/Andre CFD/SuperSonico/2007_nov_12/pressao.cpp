/*  ============= pressao.cpp ==============    Contem funcoes para resolver as equacoes    de correcao de pressao no SIMPLE.*/#include "Cell.h"#include "Grid.h"#include "functions.h"#include <cmath>#ifndef IOSTREAM__INCLUIDO#define IOSTREAM__INCLUIDO#include <iostream>    using std::cout;    using std::endl;    using std::ios;    using std::cin;#include <iomanip>    using namespace std;#endif // IOSTREAM_INCLUIDO#include "constants.h"#include "erros.h"/*______________________________________________________________________________                   calculaCoeficientesCorrecaoPressao()    Calcula os coeficientes L_p, L_e, L_w, L_n, L_s para cada celula,montando a matriz [A] do sistema associado 'a correcao de pressao.    Parametros:        malha: apontador para a malha em questao;Criado por Andre STALTZ dia 31/03/07.______________________________________________________________________________*/int calculaCoeficientesCorrecaoPressao( Grid *malha ){    Cell *celula;    short tipoFronteira;    // Declaracao dos fatores inclusos nos coeficientes    double m_P_rho = 0.0,           m_e_rho = 0.0,           m_w_rho = 0.0,           m_n_rho = 0.0,           m_s_rho = 0.0;    double m_e_u = 0.0,           m_w_u = 0.0,           m_n_v = 0.0,           m_s_v = 0.0;    double C_P_rho = 0.0,           C_E_rho = 0.0,           C_W_rho = 0.0,           C_N_rho = 0.0,           C_S_rho = 0.0;    double L_P = 0.0,           L_e = 0.0,           L_w = 0.0,           L_n = 0.0,           L_s = 0.0;    double rhoVizLeste = 0.0,           rhoVizOeste = 0.0,           rhoVizNorte = 0.0,           rhoVizSul = 0.0;    double TVizLeste = 0.0,           TVizOeste = 0.0,           TVizNorte = 0.0,           TVizSul = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Evitar caso especial dos quatro cantos ficticios: nao entram no sistema            if( celula->active )            {                // Obtem o identificador que mostra qual o tratamento para a fronteira                tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_PLINHA );                // Volume ficticio (fronteira oeste)                if( celula->direcaoFronteira == FRONTEIRA_OESTE && celula->volumeFicticio == true )                {                    // Se no OESTE for prescrito                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Coeficientes importantes para condicao dirichlet                        L_P = 1.0;                        L_e = 1.0;                        // Outros coeficientes                        L_w = 0.0; L_n = 0.0; L_s = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_PressaoLinha = 2.0 * valorCondicaoFronteira( celula->east, ID_VAR_PLINHA, 'w');                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no oeste!" << endl;                    }                }                // Volume ficticio (fronteira leste)                else if( celula->direcaoFronteira == FRONTEIRA_LESTE && celula->volumeFicticio == true )                {                    // Se o LESTE for extrapolado                    if(tipoFronteira == CONDICAO_FRONTEIRA_EXTRAPOLADA)                    {                        // Fronteira impermeavel, coeficientes importantes                        L_P = 1.0;                        L_w = -1.0;                        // Outros coeficientes                        L_e = 0.0; L_n = 0.0; L_s = 0.0;                        celula->b_PressaoLinha = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no leste!" << endl;                    }                }                // Volume ficticio (fronteira norte)                else if( celula->direcaoFronteira == FRONTEIRA_NORTE && celula->volumeFicticio == true )                {                    // Se no NORTE for prescrito                    if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)                    {                        // Coeficientes importantes para condicao dirichlet                        L_P = 1.0;                        L_s = 1.0;                        // Outros coeficientes                        L_w = 0.0; L_n = 0.0; L_e = 0.0;                        // B de acordo com 7.84 do Maliska                        celula->b_PressaoLinha = 2.0 * valorCondicaoFronteira( celula->south, ID_VAR_PLINHA, 'n');                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                              << " nao implementado no norte!" << endl;                    }                }                // Volume ficticio (fronteira sul)                else if( celula->direcaoFronteira == FRONTEIRA_SUL && celula->volumeFicticio == true )                {                    // Se o SUL for extrapolado                    if(tipoFronteira == CONDICAO_FRONTEIRA_EXTRAPOLADA)                    {                        // Fronteira impermeavel, coeficientes importantes                        L_P = 1.0;                        L_n = -1.0;                        // Outros coeficientes                        L_e = 0.0; L_w = 0.0; L_s = 0.0;                        celula->b_PressaoLinha = 0.0;                    }                    // Imprime erro de programacao                    else                    {                        cout << "Na funcao calculaCoeficientesCorrecaoPressao:" << endl                             << "Tipo de fronteira " << tipoFronteira                             << " nao implementado no sul!" << endl;                    }                }                // Volumes internos                else                {                    /*obtemVariaveisVizinhas( celula, ID_VAR_RHO, &rhoVizNorte, &rhoVizSul,                                                            &rhoVizLeste, &rhoVizOeste );                    obtemVariaveisVizinhas( celula, ID_VAR_T, &TVizNorte, &TVizSul,                                                            &TVizLeste, &TVizOeste );*/                    rhoVizNorte = celula->north->rhoAtual;                    rhoVizSul = celula->south->rhoAtual;                    rhoVizLeste = celula->east->rhoAtual;                    rhoVizOeste = celula->west->rhoAtual;                    TVizNorte = celula->north->TAtual;                    TVizSul = celula->south->TAtual;                    TVizLeste = celula->east->TAtual;                    TVizOeste = celula->west->TAtual;                    // Fator m_(P,e,w,n,s)_rho que depende de (u,v)_(e,w,n,s)^* e os gammas ---                    m_P_rho = (celula->faceLength / malha->deltaT) * celula->faceLength                            + celula->faceLength                            *(                                 (0.5 + celula->eastFaceGamma) * celula->eastFaceU                                -(0.5 - celula->westFaceGamma) * celula->westFaceU                                +(0.5 + celula->northFaceGamma) * celula->northFaceV                                -(0.5 - celula->southFaceGamma) * celula->southFaceV                             );                    m_e_rho = celula->faceLength * celula->eastFaceU                            * (0.5 - celula->eastFaceGamma);                    m_w_rho = -1.0 * celula->faceLength * celula->westFaceU                            * (0.5 + celula->westFaceGamma);                    m_n_rho = celula->faceLength * celula->northFaceV                            * (0.5 - celula->northFaceGamma);                    m_s_rho = -1.0 * celula->faceLength * celula->southFaceV                            * (0.5 + celula->southFaceGamma);                    // Fator C_(P,E,W,N,S)_rho que depende da temperatura e da equacao de estado                    C_P_rho = 1.0 / (R * celula->TAtual);                    C_E_rho = 1.0 / (R * TVizLeste);                    C_W_rho = 1.0 / (R * TVizOeste);                    C_N_rho = 1.0 / (R * TVizNorte);                    C_S_rho = 1.0 / (R * TVizSul);                    // Fatores m_(e,w,n,s)^(u,v) que dependem de rho_(E,W,N,S)^* e os gammas                    m_e_u = celula->faceLength                            *(                                (0.5 + celula->eastFaceGamma) * celula->rhoAtual                                +(0.5 - celula->eastFaceGamma) * rhoVizLeste                             );                    m_w_u = -1.0 * celula->faceLength                            *(                                (0.5 + celula->westFaceGamma) * rhoVizOeste                                +(0.5 - celula->westFaceGamma) * celula->rhoAtual                             );                    m_n_v = celula->faceLength                            *(                                (0.5 + celula->northFaceGamma) * celula->rhoAtual                                +(0.5 - celula->northFaceGamma) * rhoVizNorte                             );                    m_s_v = -1.0 * celula->faceLength                            *(                                (0.5 + celula->southFaceGamma) * rhoVizSul                                +(0.5 - celula->southFaceGamma) * celula->rhoAtual                             );                    // Fatores d_(e,w,n,s) que dependem de I_(e,w,n,s), dado pelo parametro                    // OBS: FOI EVITADA A DIVISAO POR ZERO, MAS ISTO E' QUESTIONAVEL                    celula->d_e = ( (celula->I_e == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_e) );                    celula->d_w = ( (celula->I_w == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_w) );                    celula->d_n = ( (celula->I_n == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_n) );                    celula->d_s = ( (celula->I_s == 0.0) ? celula->faceLength                                         :                                    (celula->faceLength / celula->I_s) );                    // Calcula L_P ==================================================                    L_P =   m_P_rho * C_P_rho                            + m_e_u * celula->d_e                            - m_w_u * celula->d_w                            + m_n_v * celula->d_n                            - m_s_v * celula->d_s;                    // Calcula L_(e,w,n,s) ===========================================                    L_e = -1.0 * (-1.0 * m_e_rho * C_E_rho + m_e_u * celula->d_e);                    L_w = -1.0 * (-1.0 * m_w_rho * C_W_rho - m_w_u * celula->d_w);                    L_n = -1.0 * (-1.0 * m_n_rho * C_N_rho + m_n_v * celula->d_n);                    L_s = -1.0 * (-1.0* m_s_rho * C_S_rho - m_s_v * celula->d_s);                }                /* Adicionar L_P na matriz de coeficientes de pressao */                celula->iniciaElement( L_P, &(celula->firstElementPressaoLinha) );                // Insere coeficientes dos vizinhos na mesma lista encadeada                celula->insereElement( L_e, celula->east, &(celula->firstElementPressaoLinha) );                celula->insereElement( L_w, celula->west, &(celula->firstElementPressaoLinha) );                celula->insereElement( L_n, celula->north, &(celula->firstElementPressaoLinha) );                celula->insereElement( L_s, celula->south, &(celula->firstElementPressaoLinha) );            }        }                return SUCESSO;    }    else    {        cout << "Na funcao calculaCoeficientesCorrecaoPressao():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaCoeficientesCorrecaoPressao():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                   calculaTermoFonteCorrecaoPressao()    Calcula o termo fonte b^(P') da equacao de correcao de pressao usando asvelocidades u* e v* que acabaram de ser calculados na etapa anterior. Esse termoe' somado na matriz [B] do sistema associado a correcao de pressao.    Parametros:        malha: apontador para a malha em questao;Criado por Andre STALTZ dia 31/03/07______________________________________________________________________________*/int calculaTermoFonteCorrecaoPressao( Grid *malha ){    Cell *celula;    // Declaracao dos fatores inclusos no termo fonte    double m_P_rho = 0.0,           m_e_rho = 0.0,           m_w_rho = 0.0,           m_n_rho = 0.0,           m_s_rho = 0.0;    double rhoVizLeste = 0.0,           rhoVizOeste = 0.0,           rhoVizNorte = 0.0,           rhoVizSul = 0.0;    // Se a malha possui celulas (foi inicializada)    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Volumes internos            if( celula->volumeFicticio == false )            {                /*obtemVariaveisVizinhas( celula, ID_VAR_RHO, &rhoVizNorte, &rhoVizSul,                                                        &rhoVizLeste, &rhoVizOeste );*/                rhoVizNorte = celula->north->rhoAtual;                rhoVizSul = celula->south->rhoAtual;                rhoVizLeste = celula->east->rhoAtual;                rhoVizOeste = celula->west->rhoAtual;                // Fator m_(P,e,w,n,s)_rho que depende de (u,v)_(e,w,n,s)^* e os gammas ---                m_P_rho = AO_QUADRADO( celula->faceLength ) / malha->deltaT                        + celula->faceLength                        *(                            (0.5 + celula->eastFaceGamma) * celula->eastFaceU                           -(0.5 - celula->westFaceGamma) * celula->westFaceU                           +(0.5 + celula->northFaceGamma) * celula->northFaceV                           -(0.5 - celula->southFaceGamma) * celula->southFaceV                        );                m_e_rho = celula->faceLength * celula->eastFaceU                        * (0.5 - celula->eastFaceGamma);                m_w_rho = -1.0 * celula->faceLength * celula->westFaceU                        * (0.5 + celula->westFaceGamma);                m_n_rho = celula->faceLength * celula->northFaceV                        * (0.5 - celula->northFaceGamma);                m_s_rho = -1.0 * celula->faceLength * celula->southFaceV                        * (0.5 + celula->southFaceGamma);                celula->b_PressaoLinha = celula->rhoAnterior *                                         ( AO_QUADRADO( celula->faceLength ) / malha->deltaT )                                       - m_P_rho * celula->rhoAtual                                       - m_e_rho * rhoVizLeste                                       - m_w_rho * rhoVizOeste                                       - m_n_rho * rhoVizNorte                                       - m_s_rho * rhoVizSul;            }        }        return SUCESSO;    }    else    {        cout << "Na funcao calculaTermoFonteCorrecaoPressao():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao calculaTermoFonteCorrecaoPressao():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                corrige_Velocidades_Densidades_Pressoes()    Corrige os valores das velocidades em todas as interfaces da malha, usando acorrecao de pressao, atraves de media das velocidades anteriores ponderadaspelos respectivos coeficientes na matriz. Em seguida, atraves de uma mediaaritmetica, obtem os novos valores de velocidade nos centros das celulas.    Corrige tambem os valores das densidades em todas as celulas da malha,atraves da equacao de estado e, por ultimo, calcula um novo campo de pressoes.    Parametros:        malha: apontador para a malha em questao;Criado por Henrique dia 08/05/07______________________________________________________________________________*/int corrige_Velocidades_Densidades_Pressoes( Grid *malha, double relaxamentoP = 1.0,                                             double relaxamentoU = 1.0, double relaxamentoV = 1.0 ){    // Celula da malha    Cell *celula;    short tipoFronteira;    if(malha->firstGridCell != NULL)    {        // Para cada celula da malha (correspondendo a uma linha da matriz)        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            // Correcao para os volumes internos            if( celula->active && celula->volumeFicticio == false )            {                // Corrige velocidade u na interface leste da celula atual                // Se nao esta na fronteira leste                if( celula->east->type == 'b' && celula->east->active == true)                    celula->eastFaceU -= relaxamentoU * celula->d_e                                          * ( celula->east->pLinha - celula->pLinha );                // Corrige velocidade u na interface oeste da celula atual                // Se nao esta na fronteira oeste                if( celula->west->type == 'b' && celula->west->active == true)                    celula->westFaceU -= relaxamentoU * celula->d_w                                         * ( celula->pLinha - celula->west->pLinha );                // Corrige velocidade v na interface norte da celula atual                // Se nao esta na fronteira norte                if( celula->north->type == 'b' && celula->north->active == true)                    celula->northFaceV -= relaxamentoV * celula->d_n                                          * ( celula->north->pLinha - celula->pLinha );                // Corrige velocidade v na interface sul da celula atual                // Se nao esta na fronteira sul                if( celula->south->type == 'b' && celula->south->active == true)                    celula->southFaceV -= relaxamentoV * celula->d_s                                          * ( celula->pLinha - celula->south->pLinha );                // Corrige as velocidades no centro da celula atraves de media das interfaces                celula->uAtual = ( celula->eastFaceU + celula->westFaceU ) / 2.0;                celula->vAtual = ( celula->northFaceV + celula->southFaceV ) / 2.0;                // Finalmente, corrige a pressao no centro da celula atual                if( !(celula->north->volumeFicticio) ) // fixando pressao de referencia */                    celula->pAtual += relaxamentoP * celula->pLinha;                // Corrige a densidade no centro da celula atual                celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );            }        }        // Percorre as celulas que sao volumes ficticios da fronteira leste do dominio        // para calcular a correcao de variaveis        for(celula = malha->firstGridCell->south;            celula->active;            celula = celula->south)        {            // Obtem o identificador que mostra qual o tratamento para a fronteira            tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );            // Se no LESTE for saida de massa            if(tipoFronteira == CONDICAO_FRONTEIRA_SAIDA_MASSA)            {                // u no leste                celula->uAtual += (celula->west->uAtual - celula->west->uIterAnterior);                // v no leste                celula->vAtual += (celula->west->vAtual - celula->west->vIterAnterior);            }            // Imprime erro de programacao            else            {                cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                     << "Tipo de fronteira " << tipoFronteira                     << " nao implementado no leste!" << endl;            }/*            celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );            celula->pAtual += celula->pLinha;*/            celula->uAtual =  relaxamentoU * celula->uAtual                            + (1.0 - relaxamentoU) * celula->uIterAnterior;            celula->vAtual =  relaxamentoV * celula->vAtual                            + (1.0 - relaxamentoV) * celula->vIterAnterior;            // densidade no leste            celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );            // pressao no leste            celula->pAtual += relaxamentoP * celula->pLinha;        }        // Percorre as celulas que sao volumes ficticios da fronteira sul do dominio        // para calcular a correcao de variaveis        for(celula = celula->west;            celula->active;            celula = celula->west)        {            // Obtem o identificador que mostra qual o tratamento para a fronteira            tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );            // Se no SUL for prescrito            if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)            {                // u no sul                celula->uAtual -= (celula->north->uAtual - celula->north->uIterAnterior);                // v no sul                celula->vAtual -= (celula->north->vAtual - celula->north->vIterAnterior);            }            // Imprime erro de programacao            else            {                cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                        << "Tipo de fronteira " << tipoFronteira                         << " nao implementado no sul!" << endl;            }/*            celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );            celula->pAtual += celula->pLinha;*/            celula->uAtual =  relaxamentoU * celula->uAtual                            + (1.0 - relaxamentoU) * celula->uIterAnterior;            celula->vAtual =  relaxamentoV * celula->vAtual                            + (1.0 - relaxamentoV) * celula->vIterAnterior;            // densidade no sul            celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );            // pressao no sul            celula->pAtual += relaxamentoP * celula->pLinha;        }        // Percorre as celulas que sao volumes ficticios da fronteira oeste do dominio        // para calcular a correcao de variaveis        for(celula = celula->north;            celula->active;            celula = celula->north)        {            // Obtem o identificador que mostra qual o tratamento para a fronteira            tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );            // Se no OESTE for prescrito            if(tipoFronteira == CONDICAO_FRONTEIRA_ENTRADA_MASSA)            {                // u no oeste                //celula->uAtual += 0.0; // comentado para evitar esforco inutil                // v no oeste                //celula->vAtual += 0.0; // comentado para evitar esforco inutil                /*celula->uAtual =  relaxamentoU * celula->uAtual // comentado para evitar esforco inutil                               + (1.0 - relaxamentoU) * celula->uIterAnterior;*/                /*celula->vAtual =  relaxamentoV * celula->vAtual // comentado para evitar esforco inutil                                + (1.0 - relaxamentoV) * celula->vIterAnterior;*/            }            // Imprime erro de programacao            else            {                cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                        << "Tipo de fronteira " << tipoFronteira                         << " nao implementado no oeste!" << endl;            }/*            celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );            celula->pAtual += celula->pLinha;*/            // densidade no oeste            celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );            // pressao no oeste            celula->pAtual += relaxamentoP * celula->pLinha;        }        // Percorre as celulas que sao volumes ficticios da fronteira norte do dominio        // para calcular a correcao de variaveis        for(celula = celula->east;            celula->active;            celula = celula->east)        {            // Obtem o identificador que mostra qual o tratamento para a fronteira            tipoFronteira = tipoCondicaoFronteira( celula, ID_VAR_U );            // Se no NORTE for prescrito            if(tipoFronteira == CONDICAO_FRONTEIRA_PRESCRITA)            {                // u no norte                celula->uAtual -= (celula->south->uAtual - celula->south->uIterAnterior);                // v no norte                celula->vAtual -= (celula->south->vAtual - celula->south->vIterAnterior);                celula->uAtual =  relaxamentoU * celula->uAtual                                 + (1.0 - relaxamentoU) * celula->uIterAnterior;                    celula->vAtual =  relaxamentoV * celula->vAtual                                 + (1.0 - relaxamentoV) * celula->vIterAnterior;            }            // Imprime erro de programacao            else            {                cout << "Na funcao corrige_Velocidades_Densidades_Pressoes:" << endl                        << "Tipo de fronteira " << tipoFronteira                         << " nao implementado no norte!" << endl;            }/*            celula->rhoAtual += (celula->pLinha) / ( R * celula->TAtual );            celula->pAtual += celula->pLinha;*/            // densidade no norte            celula->rhoAtual += (relaxamentoP * celula->pLinha) / ( R * celula->TAtual );            // pressao no norte            celula->pAtual += relaxamentoP * celula->pLinha;        }        return SUCESSO;    }    else    {        cout << "Na funcao corrige_Velocidades_Densidades_Pressoes():\n";        IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }    cout << "Na funcao corrige_Velocidades_Densidades_Pressoes():\n";    IMPRIMIR_ERRO_FLUXO_EXECUCAO();    return ERRO_FLUXO_EXECUCAO;}/*______________________________________________________________________________                  convergenciaPressao()   Verifica a convergencia das pressoes.   Parametros:       malha: apontador para a malha em questao;Criado por Fernando Grossi dia 25/04/07.Atualizado por Henrique dia 09/07/09.______________________________________________________________________________*/int convergenciaPressao( Grid *malha ){    Cell *celula; // Celula da malha    double deltaP = 0.0,           maiorDeltaP = 0.0,           maiorP = 0.0,           menorP = 10.0 * PRESSAO_LIVRE,           erroPressao = 0.0;    if(malha->firstGridCell != NULL)    {        // Calcula os erros na pressao de todas as celulas ativas        for(celula = malha->firstGridCell;            celula != NULL;            celula = celula->next)        {            if(celula->volumeFicticio == false && celula->active == true)            {                deltaP = fabs(celula->pAtual - celula->pIterAnterior);                if(deltaP > maiorDeltaP)                    maiorDeltaP = deltaP;                if(celula->pAtual > maiorP)                    maiorP = celula->pAtual;                if(celula->pAtual < menorP)                    menorP = celula->pAtual;            }        }        // Calcula o erro na pressao        if((maiorP - menorP) != 0.0)            erroPressao = maiorDeltaP / (maiorP - menorP);        else        {            erroPressao = maiorDeltaP;        }        // Verifica convergencia e retorna resultado        if ( erroPressao < COTA_PRESSAO )            return SUCESSO;        else{            cout << "erroPressao = " << erroPressao << endl;            return INSUCESSO;        }    }    else    {        cout << "Na funcao convergenciaPressao():\n";         IMPRIMIR_ERRO_MALHA_VAZIA();        return ERRO_MALHA_VAZIA;    }}